import structure from '~/assets/docs/structure/structure.png';

# Structure

## The Spectrum of Components

When building a design system, it's helpful to understand that components exist on a spectrum:

- **Low-level components**: Generic, highly reusable "LEGO brick" components like `Button` or `Input`
- **Mid-level components**: Combinations of low-level components with added functionality, like `SearchInput` or `NavMenu`
- **High-level components**: Application-specific components that implement business logic, like `UserProfileCard` or `CheckoutForm`

In QDS, we focus primarily on creating low-level components that are highly reusable across different applications and use cases. However, we structure them in a way that makes it easy to compose them into mid-level and high-level components.

<Image src={structure} alt="Structure" />

## Compound Components

To achieve both flexibility and simplicity, QDS uses a pattern called *compound components*. This approach allows developers to have precise control over each part of a component while maintaining a clean, organized API.

In QDS, compound components are structured as a collection of related components that share a **common namespace**. 

The component name itself serves as the namespace (like `Dropdown`), and within that namespace, we have different pieces including a `Root` component. These components work together to create a cohesive UI element, but each has a specific role.

For example, a Dropdown component might be structured like this:

```tsx
import { component$, Slot } from '@builder.io/qwik';

// The component pieces
export const DropdownRoot = component$(() => {
  return (
    <div class="dropdown">
      <Slot />
    </div>
  );
});

export const DropdownTrigger = component$(() => {
  return (
    <button class="dropdown-trigger">
      <Slot />
    </button>
  );
});

export const DropdownMenu = component$(() => {
  return (
    <div class="dropdown-menu">
      <Slot />
    </div>
  );
});

export const DropdownItem = component$(({ href }: { href: string }) => {
  return (
    <a class="dropdown-item" href={href}>
      <Slot />
    </a>
  );
});

// Creating the namespace with pieces
export const Dropdown = {
  Root: DropdownRoot,
  Trigger: DropdownTrigger,
  Menu: DropdownMenu,
  Item: DropdownItem
};
```

This enables developers to use the component like this:

```tsx
<Dropdown.Root>
  <Dropdown.Trigger>Actions</Dropdown.Trigger>
  <Dropdown.Menu>
    <Dropdown.Item href="/profile">Profile</Dropdown.Item>
    <Dropdown.Item href="/settings">Settings</Dropdown.Item>
    <Dropdown.Item href="/logout">Logout</Dropdown.Item>
  </Dropdown.Menu>
</Dropdown.Root>
```

## Benefits of Compound Components

Using compound components solves several problems:

1. **Avoids "prop explosion"** - Instead of dozens of configuration props, each piece has its own focused API
2. **Provides flexibility** - Developers can compose the pieces how they need
3. **Maintains separation of concerns** - Each piece has a clear, single responsibility
4. **Enables better abstractions** - Developers can build their own higher-level components from the primitives
5. **Type safety** - When consuming the namespace, the IDE can provide autocompletion for the available pieces

For example, a developer might create a specialized dropdown for user actions:

```tsx
export const UserActionsDropdown = component$(({ user }) => {
  return (
    <Dropdown.Root>
      <Dropdown.Trigger>User Actions</Dropdown.Trigger>
      <Dropdown.Menu>
        <Dropdown.Item href={`/user/${user.id}/profile`}>Profile</Dropdown.Item>
        <Dropdown.Item href={`/user/${user.id}/settings`}>Settings</Dropdown.Item>
        <Dropdown.Item href="/logout">Logout</Dropdown.Item>
      </Dropdown.Menu>
    </Dropdown.Root>
  );
});
```

## Organizing Component Files

When creating a new compound component for QDS, follow this file structure:

```
libs/components/src/dropdown/
├── index.ts           # Main export file that creates the namespace
├── root.tsx           # Root component piece
├── trigger.tsx         # Trigger component piece
├── menu.tsx           # Menu component piece
├── item.tsx           # Item component piece
└── research.mdx       # Research and documentation
```

The `index.ts` file creates and exports the namespace:

```tsx
import { DropdownRoot } from './root';
import { DropdownTrigger } from './trigger';
import { DropdownMenu } from './menu';
import { DropdownItem } from './item';

export const Dropdown = {
  Root: DropdownRoot,
  Trigger: DropdownTrigger,
  Menu: DropdownMenu,
  Item: DropdownItem
};
```

## Benefits of This Structure

Organizing components this way provides several benefits:

1. **Maintainability** - Each component piece has its own file, making it easier to maintain
2. **Testability** - Component pieces can be tested individually
3. **Documentation** - Each piece can have its own documentation
4. **Flexibility** - Developers can import only the namespace and use the pieces they need

By following this structure, we create components that are both powerful and easy to use, balancing flexibility with developer experience. 
import { api } from "./auto-api/api";

# Scroll Area
A customizable container that adds scrollbars when content overflows its boundaries.
<Showcase name="both" />
## Features
<Features api={api} />
## Anatomy 
<AnatomyTable api={api} />
## Examples
### Basic Usage
The scroll area provides a clean way to handle content overflow with customizable scrollbars. The basic setup includes a root component, viewport, and scrollbars.
<Showcase name="vertical" />
The example demonstrates:
- `ScrollArea.Root` as the container
- `ScrollArea.Viewport` wrapping the content
- `ScrollArea.Scrollbar` with `orientation="vertical"` for vertical scrolling
- `ScrollArea.Thumb` for the draggable scrollbar handle
### Visual Features
#### Horizontal Scrolling
For content that extends beyond the horizontal bounds, add a horizontal scrollbar.
<Showcase name="horizontal" />
This example shows:
- `ScrollArea.Scrollbar` with `orientation="horizontal"` 
- Automatic thumb sizing based on content width
- Smooth horizontal scrolling behavior
#### Both Scrollbars
When content overflows in both directions, you can combine vertical and horizontal scrollbars.
<Showcase name="both" />
This setup demonstrates:
- Multiple `ScrollArea.Scrollbar` components
- Independent vertical and horizontal scrolling
- Automatic corner handling where scrollbars meet
### Advanced Usage
#### Scrollbar Visibility Control
The scroll area supports different visibility modes through the `type` prop on `ScrollArea.Root`.

## Component State
### Internal State Structure
The ScrollArea component maintains several key state values through Qwik signals:
```typescript
// Core state signals
const viewportRef = useSignal<HTMLDivElement>();
const verticalScrollbarRef = useSignal<HTMLDivElement>();
const horizontalScrollbarRef = useSignal<HTMLDivElement>(); 
const rootRef = useSignal<HTMLDivElement>();
const thumbRef = useSignal<HTMLDivElement>();
const isScrolling = useSignal(false);
const isHovering = useSignal(false);
const scrollTimeout = useSignal<number>();
const hasOverflow = useSignal(false);
```
These signals form the foundation of the ScrollArea's state management:
- `hasOverflow`: Tracks whether content exceeds viewport dimensions
- `isScrolling`: Indicates active scrolling state
- `isHovering`: Tracks mouse hover state
- `scrollTimeout`: Manages scrollbar hide delay timing
### State Updates
The ScrollArea implements several state update patterns:
1. Overflow Detection:
```typescript
const updateOverflow = $((viewport: HTMLElement) => {
  const hasVerticalOverflow = viewport.scrollHeight > viewport.clientHeight;
  const hasHorizontalOverflow = viewport.scrollWidth > viewport.clientWidth;
  context.hasOverflow.value = hasVerticalOverflow || hasHorizontalOverflow;
});
```
2. Scroll State Management:
```typescript
if (context.type === "scroll") {
  context.isScrolling.value = true;
  clearTimeout(context.scrollTimeout.value);
  context.scrollTimeout.value = setTimeout(() => {
    context.isScrolling.value = false;
  }, context.hideDelay);
}
```
3. Hover State:
```typescript
const onMouseEnter$ = $(() => {
  if (type === "hover") {
    isHovering.value = true;
  }
});
const onMouseLeave$ = $(() => {
  if (type === "hover") {
    isHovering.value = false;
  }
});
```
4. Drag State:
```typescript
const isDragging = useSignal(false);
const dragData = useSignal({
  startClientY: 0,
  startClientX: 0,
  startScrollTop: 0,
  startScrollLeft: 0,
  activeThumb: null,
  activeScrollbar: null
});
```
The state updates are triggered by:
- Scroll events
- Mouse interactions
- Window resize
- Zoom level changes
- Content overflow changes
State visibility is determined by the `type` prop:
- `"hover"`: Shows scrollbars on hover when content overflows
- `"scroll"`: Shows scrollbars during active scrolling
- `"auto"`: Shows scrollbars when content overflows
- `"always"`: Always shows scrollbars when content overflows
<Showcase name="both" />
In this example, both vertical and horizontal scrollbars are shown, demonstrating how the component manages multiple scrollbar states simultaneously.

Based on the provided examples and API documentation, I'll write about the ScrollArea configuration options.
## Scrollbar Visibility
### Core Behavior
The ScrollArea component supports four visibility modes controlled by the `type` prop on `ScrollArea.Root`:
- `hover` (default): Shows scrollbars when hovering over the scroll area
- `scroll`: Shows scrollbars during scrolling
- `auto`: Shows scrollbars when content overflows
- `always`: Shows scrollbars whenever content overflows
As shown in the `hover-test` example above, scrollbars appear on hover and hide when the mouse leaves the scroll area.
### Hide Delay
When using `type="scroll"`, you can customize how long scrollbars remain visible after scrolling stops using the `hideDelay` prop:
```typescript
type ScrollAreaRootProps = {
  hideDelay?: number; // milliseconds
}
```
The default delay is 600ms. As shown in the `custom-delay-test` example above, you can extend this delay to 1000ms for better visibility.
## Scrollbar Orientation
### Basic Configuration
ScrollArea supports both vertical and horizontal scrollbars through the `orientation` prop on `ScrollArea.Scrollbar`:
```typescript
type ScrollBarProps = {
  orientation: "vertical" | "horizontal";
}
```
As shown in the `both` example above, you can include both orientations simultaneously for content that overflows in both directions.
### Overflow Detection
The component automatically detects content overflow and updates scrollbar visibility accordingly. This behavior is demonstrated in all examples but is particularly visible in the `auto-test` example where scrollbars only appear when content exceeds the viewport dimensions.
Key technical considerations:
- Overflow detection is responsive to window resize events
- Browser zoom level changes trigger overflow recalculation
- The component maintains proper thumb positioning during scroll events
- Scrollbar visibility updates are debounced for performance
> Note: The overflow detection system works with dynamic content and responds to DOM mutations that affect content size.





<APITable api={api} />
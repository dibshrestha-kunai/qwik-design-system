# Composition

## What is Composability?

Composability is a design principle where complex UI components are built from simple, reusable pieces that work well together. In QDS, components are designed to be composed rather than configured through numerous props.

For example, instead of a monolithic component with many configuration options, QDS provides component parts that you can combine:

```jsx
<Tooltip.Root>
  <Tooltip.Trigger>Hover me</Tooltip.Trigger>
  <Tooltip.Content>I appear on hover!</Tooltip.Content>
</Tooltip.Root>
```

This approach gives you more flexibility and control over your UI components.

[Learn more about composability in our intro guide](../intro#principle-2-composability).

## One Component, One Markup Element

A key principle in QDS is that each component typically corresponds to ONE piece of markup. With few exceptions, components are responsible for rendering and controlling a single element in the DOM.

This principle:

- Keeps components focused on a single responsibility
- Makes the relationship between components and DOM clearer
- Simplifies styling and accessibility implementations
- Avoids "div soup" and unnecessary nesting

The exceptions to this rule are primarily composite components that need to manage multiple elements as a cohesive unit, like dialogs with backdrops or components that need to manage focus traps.

By following these composition principles, QDS aims to provide a flexible foundation that can be adapted to any design system needs while maintaining accessibility and performance.

Composability means building complex UIs from simple, reusable pieces that work well together.

For example, instead of a single `<Tooltip>` component with many props, you get:

```jsx
<Tooltip.Root>
  <Tooltip.Trigger>Hover me</Tooltip.Trigger>
  <Tooltip.Content>I appear on hover!</Tooltip.Content>
</Tooltip.Root>
```

This approach gives you more control and flexibility.

Without composability, you face "prop armageddon":

```jsx
<Tooltip
  content="I appear on hover!"
  triggerText="Hover me"
  triggerProps={{ className: "btn", disabled: false }}
  triggerClass="text-blue"
  contentBackgroundColor="#333"
  contentClass="p-2 rounded"
  position="top"
  arrow={true}
  arrowSize={8}
  delay={200}
  // ...and 20 more props
/>
```

This pattern is better for those consuming the library, but not for those building it.

### Composing by abstraction

The purpose of these primitives is for consumers to abstract the complexity of the component, so you can focus on building your app.

```jsx
export const HelpTip = component$(({ trigger }) => {
  return (
    <Tooltip.Root>
      <Tooltip.Trigger asChild>
        {trigger}
      </Tooltip.Trigger>
      <Tooltip.Content class="help-bubble">
        <Slot />
      </Tooltip.Content>
    </Tooltip.Root>
  );
});

<form>
  <label>
    Username
    <HelpTip trigger={<Icon name="question-circle" />}>
      Choose a username between 3-20 characters
    </HelpTip>
  </label>
  <input name="username" />
</form>
```

### Composing with your own elements

With the `asChild` prop, you can even replace our default elements with your own:

```jsx
<Tooltip.Root>
  <Tooltip.Trigger asChild>
    <button class="my-custom-button"> 
      Hover me <Icon name="info" />
    </button>
  </Tooltip.Trigger>
  <Tooltip.Content>I appear on hover!</Tooltip.Content>
</Tooltip.Root>
```

> For more on composability, see [this article](https://atomicdesign.bradfrost.com/chapter-2/).

This lets you maintain your component structure while still getting all the built-in behavior.
# Checkbox

A customizable input that lets users select one or more options from a list.

<Showcase name="hero" />

## Features

<Features api={api} />

## Anatomy

<AnatomyTable api={api} />

## Accessibility

### Labeling

Labels are essential for screen readers to identify the checkbox's purpose.

<Showcase name="label" />

In this example, we use the `Checkbox.Label` component to provide an accessible label. The label is automatically associated with the checkbox through ARIA attributes.

### Description

Add descriptive text to provide additional context about the checkbox's purpose.

<Showcase name="description" />

This example demonstrates using `Checkbox.Description` with the `isDescription` prop on `Checkbox.Root` to provide additional context. The description is automatically associated with the checkbox through ARIA attributes.

### Error Messages

Display validation errors in an accessible way.

<Showcase name="validation" />

This example shows how to use `Checkbox.ErrorMessage` to display validation errors. The error message is automatically associated with the checkbox through ARIA attributes and updates the checkbox's `aria-invalid` state.# Checkbox

Select or deselect options with a simple click, perfect for forms and lists.

<Showcase name="hero" />

## Features

<Features api={api} />

## Anatomy

<AnatomyTable api={api} />

## Accessibility

### Labeling

Labels are essential for screen readers to identify the checkbox's purpose. Use the `Checkbox.Label` component to provide an accessible label.

<Showcase name="label" />

In this example, we use the `Checkbox.Label` component which automatically associates the label with the checkbox trigger through proper ARIA attributes.

### Description

For complex choices, provide additional context using the `Checkbox.Description` component. This text is automatically linked to the checkbox through ARIA attributes.

<Showcase name="description" />

The `isDescription` prop on `Checkbox.Root` must be set to `true` when using `Checkbox.Description`.

### Error Messages

When validation fails, use `Checkbox.ErrorMessage` to provide clear feedback. This component automatically sets the appropriate ARIA attributes for accessibility.

<Showcase name="validation" />

The error message is automatically associated with the checkbox through `aria-describedby` and sets `aria-invalid` to true.

### Form Integration

For proper form submission, include `Checkbox.HiddenInput`. This ensures the checkbox works with native form handling while maintaining accessibility.

<Showcase name="form" />

The `name` and `required` props on `Checkbox.Root` are automatically passed to the hidden input element.## Component State

### Initial State

You can set the initial checked state of the checkbox using the `checked` prop on the `Checkbox.Root` component.

<Showcase name="initial" />

### Reactive State

To bind the checkbox state to a reactive signal, use the `bind:checked` prop on the `Checkbox.Root` component. This enables two-way data binding between the checkbox and your application state.

<Showcase name="reactive" />

### Handling State Changes

The `onChange$` prop allows you to listen for changes in the checkbox state. The handler receives the new checked state as an argument.

<Showcase name="change" />

### Programmatic Control

You can programmatically control the checkbox state by modifying the signal passed to the `bind:checked` prop.

<Showcase name="programmatic" />

### Disabled State

To disable the checkbox, set the `disabled` prop to `true` on the `Checkbox.Root` component. This prevents user interaction and applies appropriate visual styling.

<Showcase name="disabled" />

### Indeterminate State

The checkbox supports an indeterminate (mixed) state, which can be useful for representing partially selected states in hierarchical selections. Set the value of `bind:checked` to `"mixed"` to enable this state.

<Showcase name="mixed-initial" />

You can also programmatically toggle between regular and indeterminate states:

<Showcase name="mixed-reactive" />

The indeterminate state automatically transitions to checked state when clicked, following the standard checkbox behavior pattern.## Component State

### Initial State

You can set the initial checked state of the checkbox using the `checked` prop on the `Checkbox.Root` component.

<Showcase name="initial" />

### Reactive State

To bind the checkbox state to a reactive signal, use the `bind:checked` prop on the `Checkbox.Root` component. This enables two-way data binding between the checkbox and your application state.

<Showcase name="reactive" />

### Handling State Changes

The `onChange$` prop allows you to listen for changes in the checkbox state. The handler receives the new checked state as an argument.

<Showcase name="change" />

### Programmatic Control

You can programmatically control the checkbox state by modifying the signal passed to the `bind:checked` prop.

<Showcase name="programmatic" />

### Disabled State

To disable the checkbox, set the `disabled` prop to `true` on the `Checkbox.Root` component. This prevents user interaction and applies appropriate visual styling.

<Showcase name="disabled" />

### Indeterminate State

The checkbox supports an indeterminate (mixed) state, which can be useful for representing partially selected states in hierarchical selections. Set the value of `bind:checked` to `"mixed"` to enable this state.

<Showcase name="mixed-initial" />

You can also programmatically toggle between regular and indeterminate states:

<Showcase name="mixed-reactive" />

The indeterminate state automatically transitions to checked state when clicked, following the standard checkbox behavior pattern.Based on the provided examples and API documentation, I don't see any specific configuration examples for the Checkbox component. The examples provided are focused on:

- Basic usage
- State management (initial, reactive, disabled)
- Form integration
- Validation
- Accessibility features (labels, descriptions, error messages)
- Mixed/indeterminate states

There are no examples demonstrating configuration options like:
- Custom filtering
- Menu behavior
- Animation configuration
- Custom positioning
- Custom timing
- Custom sorting
- etc.

The Checkbox component appears to be focused on core functionality rather than configurable behaviors. If you'd like to document configuration options, you would need to add examples demonstrating specific configurable features of the component.

Would you like me to help document a different aspect of the component, or would you like suggestions for potential configuration options that could be added to the component?Based on the provided examples and API documentation, I don't see any specific configuration examples for the Checkbox component. The examples provided are focused on:

- Basic usage
- State management (initial, reactive, disabled)
- Form integration
- Validation
- Accessibility features (labels, descriptions, error messages)
- Mixed/indeterminate states

There are no examples demonstrating configuration options like:
- Custom filtering
- Menu behavior
- Animation configuration
- Custom positioning
- Custom timing
- Custom sorting
- etc.

The Checkbox component appears to be focused on core checkbox functionality without additional configuration options that would warrant a dedicated configuration section in the documentation.

If you'd like to document configuration options, you would need examples that demonstrate specific configurable behaviors beyond the basic checkbox functionality shown in the current examples.I'll help document the behavioral aspects of the Checkbox component based on the provided examples. Let me analyze the examples that demonstrate behavioral patterns.

## Behavioral Patterns

### Mixed State

The Checkbox supports a mixed (indeterminate) state, which is useful for representing partially selected states, commonly used in parent-child checkbox relationships.

<Showcase name="mixed-reactive" />

In this example, we use:
- The `bind:checked` prop with a signal that can accept `boolean | "mixed"` type
- The `Checkbox.Indicator` component conditionally renders different icons based on the state

When in a mixed state:
1. Clicking the checkbox will set it to `checked`
2. Subsequent clicks will toggle between `checked` and `unchecked`

You can programmatically set the mixed state:

<Showcase name="mixed-initial" />

### Programmatic Control

The checkbox state can be controlled programmatically using the `bind:checked` signal:

<Showcase name="programmatic" />

This example demonstrates:
- External control of the checkbox state
- Using the `bind:checked` prop for two-way data binding
- Programmatic updates that automatically reflect in the UI

### Change Detection

You can monitor checkbox state changes using the `onChange$` prop:

<Showcase name="change" />

The `onChange$` handler:
- Receives the new checkbox state as an argument
- Is called after the internal state updates
- Can be used to trigger side effects or update other parts of your application

Note: The `onChange$` handler is not called during the initial render, only on user interactions or programmatic changes.

These behavioral patterns provide flexibility in handling complex checkbox interactions and state management scenarios in your application.I'll help document the behavioral aspects of the Checkbox component based on the provided examples. Let me analyze the examples that demonstrate behavioral patterns.

## Behavioral Patterns

### Mixed State

The Checkbox supports a mixed (indeterminate) state, which is useful for representing partially selected states, often used in parent-child checkbox relationships.

<Showcase name="mixed-reactive" />

In this example, we use:
- The `bind:checked` prop with a signal that can accept `boolean | "mixed"` type
- The `Checkbox.Indicator` component conditionally renders different icons based on the state

When in a mixed state:
- Clicking the checkbox will set it to `checked`
- Subsequent clicks will toggle between `checked` and `unchecked`
- The mixed state can only be set programmatically

### Programmatic Control

You can programmatically control the checkbox state from outside the component.

<Showcase name="programmatic" />

This example demonstrates:
- Using the `bind:checked` prop for two-way data binding
- External button triggering state changes
- The checkbox immediately reflects state changes from external controls

### Click Behavior

The checkbox can be toggled by clicking either the trigger or its associated label.

<Showcase name="label" />

Key behaviors:
- Clicking the `Checkbox.Trigger` toggles the state
- Clicking the `Checkbox.Label` also toggles the state
- The checkbox maintains a single source of truth for both interaction points

These are the main behavioral patterns demonstrated in the examples. The component follows standard checkbox interaction patterns while providing additional features like the mixed state and programmatic control.

Note: I've focused solely on behavioral aspects and excluded other topics like accessibility, state management, and form integration as requested.Based on the provided examples and component implementation, I'll document the form-related configuration for the Checkbox component.

## Forms

The checkbox can be used within forms by utilizing the `<Checkbox.HiddenInput>` component, which creates a hidden native checkbox input for form submission.

<Showcase name="form" />

The following props can be used to configure the form behavior on the `<Checkbox.Root>` component:

- `name`: Sets the name attribute for the form field
- `required`: Makes the checkbox a required form field
- `value`: Sets a custom value to be submitted (defaults to "on")

<Showcase name="value" />

When a custom `value` is provided, the form will submit that value instead of the default "on" value when the checkbox is checked.

## Validation

The checkbox supports form validation through the `<Checkbox.ErrorMessage>` component.

<Showcase name="validation" />

When the `<Checkbox.ErrorMessage>` component is rendered, the checkbox trigger receives an `aria-invalid` state and is automatically associated with the error message through `aria-describedby`.

This allows you to integrate the checkbox with any form validation library or create custom validation logic.

The error state can be triggered by:
- Form submission attempts
- Real-time validation
- External validation libraries

The error message is only displayed when rendered, making it easy to conditionally show validation feedback based on your application's needs.Based on the provided examples and component implementation, I'll document the form-related configuration for the Checkbox component.

## Forms

The checkbox can be used within forms by utilizing the `<Checkbox.HiddenInput>` component, which creates a hidden native checkbox input for form submission.

<Showcase name="form" />

The following props can be used to configure the form behavior on the `<Checkbox.Root>` component:

- `name`: Sets the name attribute for the form field
- `required`: Makes the checkbox a required form field
- `value`: Sets a custom value to be submitted (defaults to "on")

<Showcase name="value" />

When a custom `value` is provided, the form will submit that value instead of the default "on" value when the checkbox is checked.

## Validation

The checkbox supports form validation through the `<Checkbox.ErrorMessage>` component.

<Showcase name="validation" />

When the `<Checkbox.ErrorMessage>` component is rendered, the checkbox trigger receives an `aria-invalid` state and is automatically associated with the error message through `aria-describedby`.

This allows you to integrate the checkbox with any form validation library or create custom validation logic.

The error state can be triggered by:
- Form submission attempts
- Real-time validation
- External validation libraries

The error message is only displayed when rendered, making it easy to conditionally show validation feedback based on your application's needs.Based on the provided examples and component implementation, I don't see any specific environmental examples (such as CSR, SSR, or environment-specific implementations) in the showcase examples.

All the provided examples demonstrate functional aspects like state management, form handling, accessibility, and styling, but none specifically showcase environment-related implementations.

Therefore, I have no environment-specific documentation to write for this component.

---

# Checkbox

A customizable input that lets users select one or more options from a list.

<Showcase name="hero" />

## Features

<Features api={api} />

## Anatomy

<AnatomyTable api={api} />

## Accessibility

### Labeling

Labels are essential for screen readers to identify the checkbox's purpose.

<Showcase name="label" />

In this example, we use the `Checkbox.Label` component to provide an accessible label. The label is automatically associated with the checkbox through ARIA attributes.

### Description

Add descriptive text to provide additional context about the checkbox's purpose.

<Showcase name="description" />

This example demonstrates using `Checkbox.Description` with the `isDescription` prop on `Checkbox.Root` to provide additional context. The description is automatically associated with the checkbox through ARIA attributes.

### Error Messages

Display validation errors in an accessible way.

<Showcase name="validation" />

This example shows how to use `Checkbox.ErrorMessage` to display validation errors. The error message is automatically associated with the checkbox through ARIA attributes and updates the checkbox's `aria-invalid` state.## Component State

### Initial State

You can set the initial checked state of the checkbox using the `checked` prop on the `Checkbox.Root` component.

<Showcase name="initial" />

### Reactive State

To bind the checkbox state to a reactive signal, use the `bind:checked` prop on the `Checkbox.Root` component. This enables two-way data binding between the checkbox and your application state.

<Showcase name="reactive" />

### Handling State Changes

The `onChange$` prop allows you to listen for changes in the checkbox state. The handler receives the new checked state as an argument.

<Showcase name="change" />

### Programmatic Control

You can programmatically control the checkbox state by modifying the signal passed to the `bind:checked` prop.

<Showcase name="programmatic" />

### Disabled State

To disable the checkbox, set the `disabled` prop to `true` on the `Checkbox.Root` component. This prevents user interaction and applies appropriate visual styling.

<Showcase name="disabled" />

### Indeterminate State

The checkbox supports an indeterminate (mixed) state, which can be set by passing `"mixed"` as the value to either the `checked` prop or through the bound signal.

<Showcase name="mixed-initial" />

You can also control the indeterminate state programmatically:

<Showcase name="mixed-reactive" />

The indeterminate state is automatically cleared when the user interacts with the checkbox, setting it to either checked or unchecked.Based on the provided examples and API documentation, I don't see any specific configuration examples for the Checkbox component. The examples provided are focused on:

- Basic usage
- State management (initial, reactive, disabled)
- Form integration
- Validation
- Accessibility features (labels, descriptions, error messages)
- Mixed/indeterminate states

There are no examples demonstrating configuration options like:
- Custom filtering
- Menu behavior
- Animation configuration
- Custom positioning
- Custom timing
- Custom sorting
- etc.

The Checkbox component appears to be focused on core functionality rather than configurable behaviors. If you want to document configuration options, you would need examples that demonstrate customizable aspects of the component's behavior beyond its basic functionality.

Would you like me to help document a different aspect of the component, or would you like to add some configuration examples to the component first?Looking through the examples, I can identify behavioral patterns related to the checkbox's indeterminate (mixed) state functionality. Let me document this behavior:

### Indeterminate State

The checkbox supports an indeterminate (mixed) state, which is useful for representing partially selected states, commonly used in hierarchical selections like file trees or bulk actions.

When a checkbox is in an indeterminate state:
- The checkbox displays a different visual indicator (typically a minus sign)
- Clicking the checkbox will set it to `checked` state
- Subsequent clicks will toggle between `checked` and `unchecked` states

<Showcase name="mixed-initial" />

The indeterminate state can be programmatically controlled using the `bind:checked` prop with a value of `"mixed"`:

<Showcase name="mixed-reactive" />

Key Differences in Mixed State:
- Visual Representation: Uses a distinct visual indicator to represent the partial selection
- Click Behavior: First click transitions from mixed to checked, then follows normal toggle pattern
- State Flow: mixed → checked → unchecked → checked (and so on)

This behavior is particularly useful for:
- Parent checkboxes that control a group of child checkboxes
- Representing partial selections in bulk actions
- Indicating incomplete or partial states in complex forms

Note: The indeterminate state is a visual state only - the underlying input element will still submit either a checked or unchecked value when used in forms.Based on the provided examples and component implementation, I'll document the form-related configuration for the Checkbox component.

## Forms

The checkbox can be used within forms by utilizing the `<Checkbox.HiddenInput>` component, which creates a hidden native checkbox input for form submission.

<Showcase name="form" />

The following props can be used to configure the form behavior on the `<Checkbox.Root>` component:

- `name`: Sets the name attribute for the form field
- `required`: Makes the checkbox a required form field
- `value`: Sets a custom value to be submitted (defaults to "on")

<Showcase name="value" />

When a custom `value` is provided, the form will submit that value instead of the default "on" value when the checkbox is checked.

## Validation

The checkbox supports form validation through the `<Checkbox.ErrorMessage>` component.

<Showcase name="validation" />

When the `<Checkbox.ErrorMessage>` component is rendered, the checkbox trigger receives an `aria-invalid` state and is automatically associated with the error message through `aria-describedby`.

This allows you to integrate the checkbox with any form validation library or create custom validation logic.

The error state can be used to:
- Display validation messages
- Style the checkbox differently when invalid
- Provide feedback to assistive technologiesBased on the provided examples and component implementation, I don't see any specific environmental examples (such as CSR, SSR, or environment-specific implementations) in the showcase examples.

All the provided examples demonstrate functional aspects like state management, form handling, accessibility, and styling, but none specifically showcase environment-related implementations.

Therefore, I have no environment-specific documentation to write for this component.

---

# Checkbox

Select or deselect options with a simple click, supporting both binary and indeterminate states.

<Showcase name="hero" />

## Features

<Features api={api} />

## Anatomy

<AnatomyTable api={api} />

## Accessibility

### Labeling

Labels are essential for screen readers to identify the checkbox's purpose.

<Showcase name="label" />

In this example, we use the `Checkbox.Label` component to provide an accessible label. The label is automatically associated with the checkbox through ARIA attributes.

### Description

Add detailed explanatory text to help users understand the implications of their choice.

<Showcase name="description" />

This example demonstrates using the `Checkbox.Description` component to provide additional context. The description is automatically linked to the checkbox through ARIA attributes and is read by screen readers.

### Validation

Show error messages when validation fails to guide users toward correct input.

<Showcase name="validation" />

The `Checkbox.ErrorMessage` component provides accessible error feedback. When present, it's automatically announced by screen readers and visually indicates the error state through the `aria-invalid` attribute.## Component State

### Initial State

You can set the initial checked state of a checkbox using the `checked` prop on the `Checkbox.Root` component.

<Showcase name="initial" />

### Reactive State

To bind the checkbox state to a reactive signal, use the `bind:checked` prop on the `Checkbox.Root` component.

<Showcase name="reactive" />

The checkbox state can be read from the bound signal.

### Programmatic Control

The checkbox state can be controlled programmatically using the bound signal.

<Showcase name="programmatic" />

### Change Events

Listen for state changes using the `onChange$` prop. The handler receives the new checked state as an argument.

<Showcase name="change" />

### Disabled State

To disable the checkbox, set the `disabled` prop on the `Checkbox.Root` component. This prevents user interaction and applies appropriate styling.

<Showcase name="disabled" />

The disabled state can also be controlled programmatically.

### Indeterminate State

The checkbox supports an indeterminate (mixed) state, which is useful for representing partially selected states, like in a tree structure.

<Showcase name="mixed-initial" />

The indeterminate state can be set:
- Initially using `checked="mixed"`
- Reactively using a signal with `bind:checked`

<Showcase name="mixed-reactive" />

When clicked, an indeterminate checkbox transitions to the checked state, then follows the normal checked/unchecked cycle.Based on the provided examples and API documentation, I don't see any specific configuration examples for the Checkbox component. The examples provided are focused on:

- Basic usage
- State management (initial, reactive, disabled)
- Form integration
- Validation
- Accessibility features (labels, descriptions, error messages)
- Mixed/indeterminate states

There are no examples demonstrating configuration options like:
- Custom filtering
- Menu behavior
- Animation configuration
- Custom positioning
- Custom timing
- Custom sorting
- etc.

The Checkbox component appears to be focused on core checkbox functionality without additional configuration options that would warrant a dedicated configuration section in the documentation.

If you'd like to document configuration options, you would need examples that demonstrate specific configurable behaviors beyond the basic checkbox functionality shown in the current examples.Based on the provided examples and component implementation, I'll document the form-related configuration for the Checkbox component.

## Forms

The checkbox can be used within forms by utilizing the `<Checkbox.HiddenInput>` component, which creates a hidden native checkbox input for form submission.

<Showcase name="form" />

The following props can be used to configure the form behavior on the `<Checkbox.Root>` component:

- `name`: Sets the name attribute for the form field
- `required`: Makes the checkbox a required form field
- `value`: Sets a custom value to be submitted (defaults to "on")

<Showcase name="value" />

When a custom `value` is provided, the form will submit that value instead of the default "on" value when the checkbox is checked.

## Validation

The checkbox supports form validation through the `<Checkbox.ErrorMessage>` component.

<Showcase name="validation" />

When the `<Checkbox.ErrorMessage>` component is rendered, the checkbox trigger receives an `aria-invalid` state and is automatically associated with the error message through `aria-describedby`.

This allows you to integrate the checkbox with any form validation library or create custom validation logic.

The error state can be triggered by:
- Form submission attempts
- Real-time validation
- External validation libraries

The error message is only displayed when rendered, making it easy to conditionally show validation feedback based on your application's needs.Based on the provided examples and component implementation, I don't see any specific environmental examples (such as CSR, SSR, or environment-specific implementations) in the showcase examples.

All the provided examples demonstrate functionality like state management, form handling, accessibility features, and various checkbox states, but none specifically showcase environment-related implementations.

Therefore, I have no environment-specific documentation to write for this component.

---

# File Upload

A drag and drop interface for uploading files with support for filtering and multiple selections.

<Showcase name="hero" />

## Features

<Features api={api} />

## Anatomy

<AnatomyTable api={api} />

## Examples



This example demonstrates core functionality using:
- `FileUpload.Root` as the main container
- `FileUpload.Input` for handling file selection
- `FileUpload.Dropzone` for drag and drop functionality
- `FileUpload.Trigger` for opening the system file dialog
- `onFilesChange$` prop to handle uploaded files



This example shows:
- Custom styling applied to the dropzone and trigger
- Visual feedback during drag operations using `data-dragging` attribute
- File type filtering with `accept="image/*"` prop to only allow image files

### Advanced Usage


This implementation showcases:
- `multiple` prop to allow selecting multiple files
- Batch file processing through `onFilesChange$`
- Custom handling for each uploaded file
- FormData preparation for potential server uploads


This example demonstrates:
- `disabled` prop to prevent file uploads
- Visual feedback for disabled state using `data-disabled` attribute
- Blocked drag and drop interactions
- Disabled trigger button## Component State

### Internal State Structure

The File Upload component maintains several key state values through Qwik's context system:

```typescript
// Core state values
interface FileUploadContext {
  inputRef: Signal<HTMLInputElement | undefined>;  // Reference to hidden file input
  isDragging: Signal<boolean>;                     // Current drag state
  files: Signal<FileInfo[]>;                       // Selected/dropped files
  multiple: boolean;                               // Multiple file selection mode
  accept?: string;                                 // Allowed file types
  disabled?: boolean;                              // Disabled state
  onFilesChange$?: PropFunction<(files: FileInfo[]) => void>; // Change callback
}
```

The state is initialized in the `FileUploadRoot` component:

```typescript
const inputRef = useSignal<HTMLInputElement>();
const isDragging = useSignal(false);
const files = useSignal<FileInfo[]>([]);

const context = {
  inputRef,
  isDragging,
  files,
  multiple: props.multiple ?? false,
  accept: props.accept,
  disabled: props.disabled,
  onFilesChange$: props.onFilesChange$
};
```

### State Updates

The component handles state updates in two main scenarios:

1. File Selection via Input:
```typescript
const onChange$ = $((e: Event) => {
  const input = e.target as HTMLInputElement;
  if (!input.files) return;
  
  const newFiles = Array.from(input.files).map(file => ({
    name: file.name,
    size: file.size,
    type: file.type,
    lastModified: file.lastModified,
    file: noSerialize(file)
  }));

  if (context.multiple) {
    context.files.value = [...context.files.value, ...newFiles];
  } else {
    context.files.value = newFiles.slice(0, 1);
  }
  
  context.onFilesChange$?.(context.files.value);
});
```

2. Drag and Drop State:
```typescript
// Drag enter updates
const onDragEnter$ = $((e: DragEvent) => {
  if (context.disabled) return;
  if (!isDragging.value) {
    isDragging.value = true;
    context.isDragging.value = true;
  }
});

// Drag leave updates
const onDragLeave$ = $((e: DragEvent) => {
  if (context.disabled) return;
  isDragging.value = false;
  context.isDragging.value = false;
});
```

The state management ensures:
- Files are properly processed whether selected via input or dropped
- Multiple file selection is handled based on the `multiple` prop
- Drag state provides visual feedback during drag operations
- Disabled state prevents any state updates
- Parent components are notified of file changes through the callback

The state is shared across all child components through Qwik's context system, allowing coordinated updates and consistent UI feedback.Based on the provided examples and API documentation, I'll document the configuration options for the File Upload component.

## Core Configuration

### File Selection Mode

The File Upload component supports both single and multiple file selection modes through the `multiple` prop on `FileUpload.Root`.

As shown in the multiple files example above, enabling multiple file selection allows users to upload several files at once.

> By default, `multiple` is set to `false`, allowing only single file selection.

### File Type Filtering

The component supports file type filtering through the `accept` prop on `FileUpload.Root`. 

As shown in the image-only example above, you can restrict file types using MIME types or file extensions:

```typescript
// Common accept patterns
accept="image/*"           // All image types
accept=".pdf,.doc,.docx"   // Specific file extensions
accept="video/*,audio/*"   // Multiple MIME types
```

> The `accept` prop is optional. When not specified, all file types are allowed.

### Disabled State

The component can be disabled entirely using the `disabled` prop on `FileUpload.Root`. 

As shown in the disabled example above, when disabled:
- The trigger button becomes non-interactive
- Drag and drop functionality is disabled
- File input becomes disabled

### File Change Notifications

The component provides file change notifications through the `onFilesChange$` prop on `FileUpload.Root`. The callback receives an array of `FileInfo` objects:

```typescript
interface FileInfo {
  name: string;
  size: number;
  type: string;
  lastModified: number;
  file: NoSerialize<File>;
}
```

> The `file` property is non-serializable and should be processed immediately if needed for uploads.

## Technical Constraints

### Browser Support

The component requires modern browser features:
- HTML5 File API
- Drag and Drop API
- DataTransfer API

### File Size Limitations

File size limits are determined by:
- Browser memory constraints
- Input element limitations
- JavaScript heap size

> It's recommended to implement server-side file size validation for production use.

### Performance Considerations

For optimal performance:
- Process files in batches when handling multiple files
- Use `URL.createObjectURL()` for image previews
- Release object URLs when no longer neededLooking through the examples and implementation, I don't see any specific form-related examples or features that would warrant a Forms section in the documentation.

The FileUpload component is primarily focused on handling file selection and upload functionality through drag & drop or file dialog interactions. While files could be part of a larger form, the component itself doesn't have specific form integration features like:

- Form field validation
- Form state integration 
- Form submission handling
- Native form element bindings

The examples show file selection and handling through callbacks (`onFilesChange$`), but don't demonstrate form-specific functionality.

If form integration examples were to be added in the future, they could demonstrate:

- Using the component within a `<form>` element
- Integration with form validation libraries
- Form submission handling with FormData
- Error state handling and validation messages

But since these aren't currently implemented, I'll skip the Forms section to avoid documenting non-existent features.Based on the provided examples and component implementation, I don't see any specific environment-related examples or features that would warrant dedicated environment documentation.

The FileUpload component works consistently across server and client environments without requiring special handling. The core functionality - drag and drop, file selection, and file processing - operates the same way regardless of the rendering environment.

While the component does handle client-side interactions like drag events and file selection, these are fundamental to the component's functionality rather than environment-specific features.

Since there are no examples demonstrating environment-specific behavior or implementation differences between server and client rendering, I'll leave this section empty to avoid creating unnecessary documentation.

---

# QR Code

Generate scannable codes to encode text, URLs, and other data in a visual format.

<Showcase name="base" />

## Features

<Features api={api} />

## Anatomy

<AnatomyTable api={api} />

## Examples

### Basic Usage

The QR code component requires a value to encode and an error correction level. The `value` prop specifies the content to encode, while the `level` prop determines error correction strength.

<Showcase name="base" />

In this example, we use:
- `QRCode.Root` with `value` and `level` props
- `QRCode.Frame` for containing the QR code
- `QRCode.PatternSvg` for setting dimensions
- `QRCode.PatternPath` for rendering the actual QR code pattern

### Visual Features

You can customize the appearance of your QR code with overlays and custom colors.

<Showcase name="overlay-custom-color" />

This example demonstrates:
- Custom fill color using the `fill` prop on `QRCode.PatternPath`
- Custom background styling through CSS classes
- Image overlay using `QRCode.Overlay` component

### Advanced Usage

Multiple QR codes can be rendered on the same page, each with unique values and styling.

<Showcase name="multiple" />

This example shows:
- Multiple QR code instances with different values
- Independent styling and overlay configuration
- Proper spacing and layout management

Each QR code maintains its own context and can be styled independently while preserving proper functionality.## Component State

### Internal State Structure

The QR code component maintains three core state values using Qwik's `useSignal`:

```typescript
const value = useSignal(props.value || "");
const level = useSignal(props.level || "L");
const data = useSignal<boolean[][]>([]);
```

- `value`: Stores the text to be encoded in the QR code
- `level`: Controls the error correction level ("L", "M", "Q", "H")
- `data`: Holds the generated QR code matrix as a 2D boolean array

These values are managed by the `QRCode.Root` component and shared with child components through Qwik's context system:

```typescript
const context = {
  value,
  level,
  data
};
useContextProvider(qrCodeContextId, context);
```

### State Updates

The QR code updates automatically when either the `value` or `level` signals change. This is handled by a `useTask$` that tracks these dependencies:

```typescript
useTask$(({ track }) => {
  track(() => value.value);
  track(() => level.value);
  const qrResult = encode(value.value, {
    ecc: level.value,
    border: 0
  });
  data.value = qrResult.data;
});
```

As shown in the `base` example above, the QR code pattern updates reactively when the value changes. The pattern is rendered through the `QRCodePatternPath` component, which transforms the boolean matrix into SVG path data:

```typescript
const pathData = context.data.value.reduce((acc, row, y) => {
  row.forEach((isBlack, x) => {
    if (isBlack) {
      acc += `M ${x} ${y} h 1 v 1 h -1 z `;
    }
  });
  return acc;
}, "");
```

The `multiple` example demonstrates how each QR code instance maintains its own independent state, allowing multiple QR codes with different values to coexist on the same page.

The state management system ensures that:
- Initial values can be provided through props
- Changes to value or error correction level trigger immediate updates
- The QR code matrix is automatically regenerated when needed
- State is properly isolated between multiple instancesBased on the provided implementation and examples, I'll document the QR code component's configuration options.

## Core Configuration

### QR Code Value and Error Correction

The QR code content and error correction level can be configured through the `QRCode.Root` component's props:

- `value`: The text or URL to encode (string)
- `level`: Error correction level ("L", "M", "Q", "H")

As shown in the `base` example above, you can set these properties to generate a basic QR code with default settings.

```typescript
type ErrorCorrectionLevel = "L" | "M" | "Q" | "H";
// L = Low (7% recovery)
// M = Medium (15% recovery)
// Q = Quartile (25% recovery)
// H = High (30% recovery)
```

> The default error correction level is "L" if not specified.

### Dimensions and Scaling

The QR code's size is controlled through the `width` and `height` props on the `QRCode.PatternSvg` component. As shown in all examples above, the default size is 200x200 pixels.

The QR code pattern automatically scales to fit within these dimensions while maintaining its aspect ratio, thanks to the SVG viewBox calculation.

## Advanced Configuration

### Custom Pattern Rendering

The QR code pattern can be customized using the `fill` attribute on `QRCode.PatternPath`. As shown in the `overlay-custom-color` example above, you can change the pattern color to any valid CSS color value.

### Overlay Configuration

The `QRCode.Overlay` component supports custom content positioning. As demonstrated in the `overlay` example above, it automatically centers the content over the QR code while maintaining code readability.

> Important: When using overlays, it's recommended to use a higher error correction level ("H") to ensure the QR code remains scannable despite the overlay content.

### Technical Constraints

- The QR code is generated with zero borders by default
- The pattern data is dynamically updated when either the `value` or `level` props change
- The SVG pattern uses a path-based rendering approach for optimal performance and scaling
- The component maintains a 1:1 aspect ratio regardless of container dimensionsBased on the provided component implementation, examples, and APIs, I don't see any form-specific features or examples for the QR Code component. The component is primarily focused on displaying and customizing QR codes rather than form integration.

The available examples (`base`, `multiple`, `overlay`, and `overlay-custom-color`) demonstrate visual customization and multiple instance usage, but none show form integration, validation, or submission handling.

Since there are no form-specific features to document, this section can be skipped. The QR Code component is designed to be a display component rather than a form input component.

If form integration becomes necessary in the future, features like:
- Form field integration
- Value validation
- Form submission handling
- Form state management

would need to be implemented and documented.Based on the provided examples and implementation, I don't see any environment-specific examples or features that would warrant documentation about server vs. client rendering, platform-specific behavior, environmental dependencies, or special rendering cases.

The examples provided (`base`, `multiple`, `overlay`, and `overlay-custom-color`) demonstrate basic usage patterns, styling variations, and component composition, but don't showcase any environment-specific functionality.

The QR Code component appears to work consistently across different rendering environments without special considerations, so there's no need for environment-specific documentation in this case.

If environment-specific examples or features are added in the future, this section should be updated accordingly.

---

# Scroll Area

A customizable container that adds scrollbars when content overflows its boundaries.

<Showcase name="both" />

## Features

<Features api={api} />

## Anatomy

<AnatomyTable api={api} />

## Examples

### Basic Usage

The scroll area component can be configured with different scrollbar visibility behaviors using the `type` prop.

<Showcase name="vertical" />

This example demonstrates:
- Using `ScrollArea.Root` with default `type="hover"` visibility
- Vertical scrollbar appears when content overflows
- The `ScrollArea.Viewport` wraps the content
- `ScrollArea.Scrollbar` and `ScrollArea.Thumb` create the custom scrollbar

### Visual Features

#### Horizontal Scrolling

For content that extends beyond the horizontal bounds, add a horizontal scrollbar.

<Showcase name="horizontal" />

This example shows:
- Setting `orientation="horizontal"` on `ScrollArea.Scrollbar`
- Horizontal thumb moves as content scrolls left/right
- Content container width controls when horizontal scrolling activates

#### Both Scrollbars

When content overflows in both directions, both scrollbars can be displayed simultaneously.

<Showcase name="both" />

This example demonstrates:
- Multiple `ScrollArea.Scrollbar` components with different orientations
- Automatic thumb sizing based on content dimensions
- Smooth interaction between vertical and horizontal scrolling

### Advanced Usage


This example shows:
- Setting `type="always"` for persistent scrollbars
- Scrollbars remain visible even when not actively scrolling
- The `hideDelay` prop can be used with `type="scroll"` to control how long scrollbars remain visible after scrolling stops## Component State

The ScrollArea component maintains several internal state values to manage scrollbar visibility, dragging behavior, and overflow detection.

1. Internal State Structure

The core state is managed through the ScrollArea context:

```typescript
interface ScrollAreaContext {
  // Element References
  thumbRef: Signal<HTMLDivElement | undefined>;
  viewportRef: Signal<HTMLDivElement | undefined>;
  verticalScrollbarRef: Signal<HTMLDivElement | undefined>;
  horizontalScrollbarRef: Signal<HTMLDivElement | undefined>;
  rootRef: Signal<HTMLDivElement | undefined>;
  
  // Visibility Control
  type: ScrollbarVisibility;
  hideDelay: number;
  
  // State Flags
  isScrolling: Signal<boolean>;
  isHovering: Signal<boolean>;
  scrollTimeout: Signal<number>;
  hasOverflow: Signal<boolean>;
}
```

2. State Updates

The component handles state updates through several mechanisms:

Scrollbar Visibility:
```typescript
const shouldShow = () => {
  const hasOverflow = context.hasOverflow.value;
  switch (context.type) {
    case "always":
      return hasOverflow;
    case "hover":
      return context.isHovering.value && hasOverflow;
    case "scroll":
      return context.isScrolling.value && hasOverflow;
    case "auto":
      return hasOverflow;
    default:
      return false;
  }
};
```

Drag State Management:
```typescript
const dragData = useSignal({
  startClientY: 0,
  startClientX: 0,
  startScrollTop: 0,
  startScrollLeft: 0,
  activeThumb: null as HTMLElement | null,
  activeScrollbar: null as HTMLElement | null
});
```

Overflow Detection:
```typescript
const updateOverflow = $((viewport: HTMLElement) => {
  const hasVerticalOverflow = viewport.scrollHeight > viewport.clientHeight;
  const hasHorizontalOverflow = viewport.scrollWidth > viewport.clientWidth;
  context.hasOverflow.value = hasVerticalOverflow || hasHorizontalOverflow;
});
```

The state updates are triggered by:
- Mouse events (enter/leave for hover state)
- Scroll events (for scroll visibility)
- Resize events (for overflow detection)
- Zoom level changes (for overflow recalculation)
- Drag operations (for thumb positioning)

The ScrollArea maintains these states independently for both vertical and horizontal scrollbars, allowing for precise control over scrollbar behavior and visibility based on user interaction and content overflow conditions.Based on the provided implementation and examples, I'll document the ScrollArea configuration options:

## Scrollbar Visibility

### Visibility Modes

The ScrollArea component supports four visibility modes controlled by the `type` prop on `ScrollArea.Root`:

- `hover` (default): Shows scrollbars when hovering over the scroll area
- `scroll`: Shows scrollbars during scrolling
- `auto`: Always shows scrollbars when content overflows
- `always`: Always shows scrollbars when content overflows

As shown in the `hover-test` example above, scrollbars appear on hover and hide when the mouse leaves.

### Hide Delay

For the `scroll` visibility mode, you can customize how long scrollbars remain visible after scrolling stops using the `hideDelay` prop:

```typescript
type PublicRootProps = {
  hideDelay?: number; // milliseconds
}
```

The default delay is 600ms. As shown in the `custom-delay-test` example above, you can extend this delay for better visibility.

## Scrollbar Configuration

### Orientation

ScrollArea supports both vertical and horizontal scrollbars through the `orientation` prop on `ScrollArea.Scrollbar`:

```typescript
type PublicScrollBarType = {
  orientation?: "vertical" | "horizontal";
}
```

As shown in the `both` example above, you can use both orientations simultaneously for content that overflows in both directions.

### Overflow Detection

The ScrollArea automatically detects content overflow and manages scrollbar visibility accordingly. This includes:

- Automatic detection of viewport size changes
- Handling of browser zoom levels
- Response to content size changes

The overflow state is exposed through the `data-has-overflow` attribute on the root element.

## Technical Constraints

1. Viewport Dimensions
   - The ScrollArea requires explicit dimensions (height/width) on the root element
   - Dimensions can be set via inline styles or CSS classes

2. Performance Considerations
   - Scrollbar visibility changes use CSS transitions for smooth animations
   - Thumb position updates are optimized using transform translations
   - Overflow detection is debounced during zoom operations

3. Browser Support Requirements
   - Requires browsers that support:
     - ResizeObserver API
     - CSS transforms
     - Mouse event handling
     - Wheel event normalization

These technical aspects ensure smooth scrolling behavior while maintaining performance across different browsers and scenarios.Based on the provided examples and API documentation, I don't see any form-specific examples or functionality in the ScrollArea component. The ScrollArea component is primarily focused on providing scrollable content areas with customizable scrollbars and does not include form-specific features such as:

- Form integration
- Form validation
- Form submission
- Form state handling

The examples provided (`both`, `horizontal`, `vertical`) demonstrate the basic usage and layout functionality of the ScrollArea component, but none are related to form functionality.

Therefore, there is no form-specific documentation to write for this component.Looking through the provided examples and implementation, I don't see any environment-specific examples (like CSR vs SSR) or features that would require special documentation about environmental concerns.

The examples provided (`both`, `horizontal`, `vertical`) demonstrate basic usage patterns and different scrollbar orientations, but don't showcase any environment-specific behavior.

The ScrollArea component appears to work consistently across server and client environments without any special considerations or limitations. It handles both initial server-side rendering and client-side hydration seamlessly through Qwik's default behavior.

Since there are no environment-specific examples or features to document, this section should be empty to avoid creating unnecessary documentation.

---

# Calendar
Select dates with an interactive grid that supports keyboard navigation and localization.
<Showcase name="hero" />
## Features
<Features api={api} />
## Anatomy 
<AnatomyTable api={api} />
## Examples
### Basic Usage
The calendar can be implemented with minimal configuration using the compound components pattern. The example below shows a basic calendar setup with navigation controls and date selection.
<Showcase name="hero" />
This example demonstrates:
- `Calendar.Root` as the main container with `locale` and `showWeekNumber` props
- `Calendar.Header` containing navigation controls and month/year display
- `Calendar.Grid` rendering the date grid with `Calendar.GridDay` for individual dates
- Date selection handling through `onDateChange$` prop on `Calendar.GridDay`
Key API highlights:
- `locale` prop for internationalization (defaults to "en")
- `showWeekNumber` prop to display week numbers (defaults to false) 
- `showDaysOfWeek` prop to show/hide weekday headers (defaults to true)
- `onDateChange$` event handler for date selection
- `data-selected` and `data-current` attributes for styling selected and current dates
The calendar supports full keyboard navigation and follows WAI-ARIA calendar design patterns for accessibility.
Note: Since only the "hero" example is available in the provided examples list, I've limited the documentation to this basic usage section. Additional sections for Visual Features and Advanced Usage would require more example implementations.## Component State
### Internal State Structure
The Calendar component maintains several key pieces of state through the `CalendarContext`:
```typescript
type CalendarContext = {
  locale: Locale;
  defaultDate: LocalDate;
  activeDate: Signal<LocalDate | null>;
  dateToFocus: Signal<LocalDate>;
  showWeekNumber: boolean;
  showDaysOfWeek: boolean;
  daysOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
  datesArray: Signal<(string | null)[][]>;
  monthToRender: Signal<Month>;
  yearToRender: Signal<number>;
  currentDate: LocalDate;
  localId: string;
  isPopoverOpenSig: Signal<boolean>;
};
```
Core state values include:
- `activeDate`: Tracks the currently selected date
- `dateToFocus`: Manages keyboard focus within the calendar grid
- `monthToRender` and `yearToRender`: Control which month/year is displayed
- `datesArray`: Contains the matrix of dates to render in the grid
The state is initialized in `CalendarRoot` with default values and optional props:
```typescript
const defaultDate = props.defaultDate ?? currentDate;
const activeDate = useSignal<LocalDate | null>(null);
const monthToRender = useSignal<Month>(defaultDate.split("-")[1] as Month);
const yearToRender = useSignal<number>(+defaultDate.split("-")[0]);
```
### State Updates
The calendar state updates through several patterns:
1. Date Selection:
```typescript
onClick$={[
  $(() => {
    context.activeDate.value = day as LocalDate;
    onDateChange$?.(day as LocalDate);
  })
]}
```
2. Month Navigation:
```typescript
// Previous month
const decreaseDate = $(() => {
  if (monthToRender.value === "01") {
    monthToRender.value = "12";
    yearToRender.value--;
    return;
  }
  monthToRender.value = String(+monthToRender.value - 1).padStart(2, "0") as Month;
});
// Next month
const increaseDate = $(() => {
  if (monthToRender.value === "12") {
    monthToRender.value = "01";
    yearToRender.value++;
    return;
  }
  monthToRender.value = String(+monthToRender.value + 1).padStart(2, "0") as Month;
});
```
3. Focus Management:
The calendar maintains focus state through the `dateToFocus` signal, which updates based on keyboard navigation:
```typescript
const updateFocus = (newIdx: number, newDate: LocalDate | null = null) => {
  const dateToSet = newDate ?? (buttons[newIdx].getAttribute("data-value") as LocalDate);
  context.dateToFocus.value = dateToSet;
  elFocus?.setAttribute("tabindex", "-1");
  buttons[newIdx].setAttribute("tabindex", "0");
  buttons[newIdx].focus({ preventScroll: true });
};
```
The state updates are reactive and trigger re-renders of the calendar grid while maintaining proper focus management and selection state.Based on the provided implementation and examples, I'll document the calendar configuration options:
## Core Configuration
### Locale and Date Format
The calendar supports localization through the `locale` prop on `Calendar.Root`. Currently, it supports:
- Default locale: `"en"`
- Date format: `YYYY-MM-DD`
As shown in the hero example above, the calendar uses the default English locale for month names, weekday labels, and date formatting.
### Initial Display
The calendar's initial display can be configured through these `Calendar.Root` props:
```typescript
{
  // Initial date shown when calendar loads
  defaultDate?: LocalDate;  
  // Whether to show week numbers
  showWeekNumber?: boolean; // default: false
  // Whether to show days of week header
  showDaysOfWeek?: boolean; // default: true
  // Show complete weeks with days from adjacent months
  fullWeeks?: boolean; // default: false
}
```
### Grid Structure
The calendar grid layout is controlled through `Calendar.Grid` and supports:
- Week numbers display (optional)
- Days of week header (optional) 
- Full/partial week display
- Responsive grid sizing
> The grid automatically adjusts its layout based on the `showWeekNumber` and `showDaysOfWeek` props.
## Advanced Configuration
### Date Selection
The calendar supports controlled and uncontrolled date selection through:
```typescript
{
  // Currently selected date (controlled)
  date?: LocalDate;
  // Handler for date selection
  onDateChange$?: (date: LocalDate) => void;
}
```
### Date Constraints
The calendar enforces these date format constraints:
- Dates must be in `YYYY-MM-DD` format
- Month values must be `01-12`
- Day values must be valid for the given month
- Invalid date formats will throw an error
> The calendar validates date strings against the regex pattern: `/^\d{4}-(0[1-9]|1[0-2])-\d{2}$/`
### Popover Integration
When used with popover functionality, the calendar supports:
```typescript
{
  // Control popover open state
  "bind:open"?: Signal<boolean>;
}
```
This enables integration with popover positioning and focus management systems.Based on the provided code and examples, there are no form-specific features or examples shown for the Calendar component. The component appears to be focused on date selection and display functionality rather than form integration.
The example provided (`hero`) demonstrates basic date selection and display, but does not show any form-specific implementations such as:
- Form field integration
- Form validation
- Form submission handling
- Form state management
Since there are no form-specific features to document, this section can be skipped. The Calendar component's primary purpose appears to be as a standalone date selection interface rather than a form input component.
If form integration is needed, it would need to be implemented by capturing the selected date value (as shown in the hero example using `onDateChange$`) and manually integrating it into a form system.Based on the provided examples and implementation, I don't see any environment-specific examples (like CSR vs SSR) for the Calendar component. The only example provided shows basic usage of the calendar component.
Since there are no environment-specific examples or features to document, I'll skip this section as per the rules. The Calendar component appears to work consistently across environments without any special considerations needed for server vs client rendering or platform-specific behavior.
If environment-specific examples or features are added in the future, this section should be updated to document those specific cases.

---

# Checklist
A group of selectable items that can be toggled individually or all at once.
<Showcase name="hero" />
## Features
<Features api={api} />
## Anatomy
<AnatomyTable api={api} />
## Examples
### Basic Usage
Create a simple checklist with multiple selectable items.
<Showcase name="select-all" />
This example demonstrates the core functionality of the checklist component:
- `Checklist.Root` serves as the container for all checklist items
- `Checklist.SelectAll` creates a master checkbox that controls all items
- `Checklist.Item` represents individual checkable items
- `Checklist.ItemTrigger` provides the interactive area for each item
- `Checklist.ItemIndicator` displays the checked state
- `Checklist.Label` and `Checklist.ItemLabel` provide accessible text labels
The select-all functionality automatically manages the state of all items, including a mixed state when only some items are selected.
Note: The available examples are limited to "hero" and "select-all". Additional examples would typically cover visual features and advanced usage patterns, but they are not included in the provided example list.## Component State
### Internal State Structure
The Checklist component maintains two primary state values through the `ChecklistContext`:
```typescript
type ChecklistContext = {
  isAllCheckedSig: Signal<boolean | "mixed">;
  checkedStatesSig: Signal<(boolean | "mixed")[]>;
};
```
1. `isAllCheckedSig`: Tracks the state of the select-all checkbox
   - `true`: All items are checked
   - `false`: No items are checked 
   - `"mixed"`: Some items are checked
2. `checkedStatesSig`: Maintains an array of individual checkbox states
The state is initialized when the `ChecklistRoot` component mounts:
```typescript
const isAllCheckedSig = useSignal(false);
const checkedStatesSig = useSignal<(boolean | "mixed")[]>([]);
```
### State Updates
The Checklist implements a bidirectional state management system:
1. Select All → Individual Items
```typescript
useTask$(function checkAllManager({ track }) {
  track(() => context.isAllCheckedSig.value);
  if (context.isAllCheckedSig.value === true) {
    isCheckedSig.value = true;
  } else if (context.isAllCheckedSig.value === false) {
    isCheckedSig.value = false;
  }
});
```
2. Individual Items → Select All
```typescript
useTask$(function checkItemsManager({ track }) {
  track(() => isCheckedSig.value);
  context.checkedStatesSig.value[index] = isCheckedSig.value;
  if (context.checkedStatesSig.value.every((state) => state === true)) {
    context.isAllCheckedSig.value = true;
  } else if (context.checkedStatesSig.value.every((state) => state === false)) {
    context.isAllCheckedSig.value = false;
  } else {
    context.isAllCheckedSig.value = "mixed";
  }
});
```
As shown in the "select-all" example above, when the select-all checkbox is toggled:
- It updates `isAllCheckedSig`
- The change propagates to all individual items
- Each item updates its local state
- The collective state is reflected back to determine if all/some/none are checked
This creates a synchronized state system where:
- Individual items can be toggled independently
- The select-all checkbox reflects the aggregate state
- Toggling select-all affects all items simultaneouslyBased on the provided implementation and examples, I'll document the configuration options for the Checklist component.
## Core Configuration
### Basic Structure
The Checklist component requires a specific structure to function properly. The root component must contain individual checklist items, each with their own trigger and indicator components.
As shown in the `hero` example above, the basic structure consists of:
- `Checklist.Root` - The container component
- `Checklist.Item` - Individual checkbox items
- `Checklist.ItemTrigger` - The interactive trigger element
- `Checklist.ItemIndicator` - Visual indicator for checked state
### Select All Configuration
The Checklist supports a "select all" functionality that can be implemented using dedicated components. As shown in the `select-all` example above, this requires:
- `Checklist.SelectAll` - The select all trigger
- `Checklist.SelectAllIndicator` - Visual indicator for the select all state
- `Checklist.Label` - Label for the select all checkbox
The select all functionality automatically manages three states:
- Unchecked (when no items are selected)
- Mixed (when some items are selected)
- Checked (when all items are selected)
### State Management
The Checklist uses an internal context system to manage the state of all checkboxes. Key technical details:
```typescript
type ChecklistContext = {
  isAllCheckedSig: Signal<boolean | "mixed">;
  checkedStatesSig: Signal<(boolean | "mixed")[]>;
};
```
> The context automatically synchronizes states between individual items and the select all checkbox. No additional configuration is required.
### Item Tracking
The Checklist internally tracks items using index positions. This is handled automatically, but you should be aware that:
```typescript
type PublicChecklistItemProps = {
  _index?: number; // Automatically managed
};
type PublicChecklistRootProps = {
  _numItems?: number; // Automatically managed
};
```
> These internal props are managed by the component and should not be set manually.
The component will throw an error if a Checklist Item is rendered without proper index tracking:
```typescript
if (props._index === undefined) {
  throw new Error("Qwik Design System: Checklist Item must have an index");
}
```Based on the provided implementation and examples, I'll document the form-specific features of the Checklist component.
## Forms
The Checklist component provides form integration through the `<Checklist.HiddenInput>` component, which manages multiple checkbox form inputs. This allows the checklist to work within forms while maintaining its group functionality.
<Showcase name="select-all" />
In this example, the checklist demonstrates form integration with multiple selectable items. The `<Checklist.HiddenInput>` component manages the form state for all checkbox items within the checklist group.
## Form State Management
The checklist maintains synchronized state management between individual items and the select-all functionality. When used in forms:
- Individual items can be selected/deselected independently
- The select-all state automatically updates based on item selections:
  - All items checked: select-all is checked
  - No items checked: select-all is unchecked
  - Some items checked: select-all shows a mixed state
## Form Validation
Form validation can be handled through the `<Checklist.ErrorMessage>` component. When rendered, it indicates an invalid state for the checklist group.
The error message component integrates with the checklist's accessibility features and can be used with any form validation library.
Note: The examples provided don't explicitly show form validation, but the component includes the necessary structure through `<Checklist.ErrorMessage>` to support validation scenarios.Based on the provided examples and implementation, I don't see any environment-specific examples (like CSR vs SSR) or environment-specific features that need to be documented separately.
The examples provided ("hero" and "select-all") demonstrate basic usage patterns and state management, but don't showcase any environment-specific behaviors or rendering cases.
Following the strict rules provided, I should not create documentation for basic usage patterns or features that have been covered in other sections. Since there are no environment-specific examples or features to document, this section should remain empty.

---

# Checklist
A group of selectable items that can be toggled together or individually.
<Showcase name="hero" />
## Features
<Features api={api} />
## Anatomy
<AnatomyTable api={api} />
## Examples
### Basic Usage
The basic checklist setup allows users to select multiple items independently.
<Showcase name="hero" />
This example demonstrates:
- Using `Checklist.Root` as the container
- Individual items created with `Checklist.Item`
- Each item has a trigger, indicator, and label
- Custom icon using `LuCheck` for the checked state
### Advanced Usage
The select-all pattern enables bulk selection of all checklist items.
<Showcase name="select-all" />
This example shows:
- `Checklist.SelectAll` trigger for controlling all items
- `Checklist.SelectAllIndicator` displaying mixed states with different icons
- Nested items indented under the select-all control
- Synchronized state between select-all and individual items
- Mixed state indication when only some items are selected
The select-all example demonstrates how the checklist manages group selection while maintaining individual item control. The mixed state is shown using a minus icon when some but not all items are selected.
Note: Both examples use the same base styling for consistency, but the select-all pattern adds hierarchical structure through layout and indentation.## Component State
### Internal State Structure
The Checklist component manages state through a context-based system that coordinates between the select-all functionality and individual checklist items.
Core state values:
```typescript
type ChecklistContext = {
  isAllCheckedSig: Signal<boolean | "mixed">;
  checkedStatesSig: Signal<(boolean | "mixed")[]>;
};
```
- `isAllCheckedSig`: Controls the state of the select-all checkbox
- `checkedStatesSig`: Tracks the checked state of each individual item
The state is initialized in the `ChecklistRoot` component:
```typescript
const isAllCheckedSig = useSignal(false);
const checkedStatesSig = useSignal<(boolean | "mixed")[]>([]);
```
### State Updates
The state updates follow a bidirectional pattern:
1. Select All → Individual Items:
```typescript
useTask$(function checkAllManager({ track }) {
  track(() => context.isAllCheckedSig.value);
  if (context.isAllCheckedSig.value === true) {
    isCheckedSig.value = true;
  } else if (context.isAllCheckedSig.value === false) {
    isCheckedSig.value = false;
  }
});
```
2. Individual Items → Select All:
```typescript
useTask$(function checkItemsManager({ track }) {
  track(() => isCheckedSig.value);
  context.checkedStatesSig.value[index] = isCheckedSig.value;
  // Update select all state based on item states
  if (context.checkedStatesSig.value.every((state) => state === true)) {
    context.isAllCheckedSig.value = true;
  } else if (context.checkedStatesSig.value.every((state) => state === false)) {
    context.isAllCheckedSig.value = false;
  } else {
    context.isAllCheckedSig.value = "mixed";
  }
});
```
As shown in the `select-all` example above, when individual items are checked/unchecked:
- The select-all checkbox shows:
  - Checked (✓) when all items are selected
  - Mixed state (-) when some items are selected
  - Unchecked when no items are selected
- Toggling the select-all checkbox affects all individual item states
The state management ensures consistent synchronization between the select-all functionality and individual checklist items through Qwik's reactive system.Based on the provided implementation and examples, I'll document the configuration options for the Checklist component.
## Core Configuration
### Basic Structure
The Checklist component requires a specific structure to function properly. As shown in the `hero` example above, the basic configuration includes:
- `<Checklist.Root />` as the main container
- `<Checklist.Item />` for individual checkboxes
- `<Checklist.ItemTrigger />` for the interactive element
- `<Checklist.ItemIndicator />` for the visual state
- `<Checklist.ItemLabel />` for the text label
### Select All Configuration
The Checklist supports a "select all" feature that can be configured using dedicated components. As demonstrated in the `select-all` example above, this requires:
- `<Checklist.SelectAll />` for the main trigger
- `<Checklist.SelectAllIndicator />` for the visual state
- `<Checklist.Label />` for the select all label
The select all functionality automatically manages the state of all child checkboxes:
- When all items are checked, the select all checkbox is checked
- When some items are checked, the select all checkbox shows a mixed state
- When no items are checked, the select all checkbox is unchecked
### State Management
The Checklist uses an internal context system to manage state synchronization between the select all checkbox and individual items. This is handled automatically and requires no additional configuration.
> Note: The Checklist maintains an array of checked states internally, so you don't need to manage individual checkbox states manually.
### Technical Constraints
1. Each `<Checklist.Item />` must be a direct child of `<Checklist.Root />` for proper state management.
2. The select all configuration must be placed before the individual checklist items in the DOM structure.
3. The component uses a group role by default and should not be modified for accessibility compliance.
These configuration options provide the foundation for building accessible and interactive checklists with synchronized state management.Based on the provided implementation and examples, I'll document the form-specific features of the Checklist component.
## Forms
The Checklist component provides form integration through the `<Checklist.HiddenInput>` component, which manages multiple checkbox form inputs.
<Showcase name="hero" />
The Checklist can be used in forms to handle multiple selections as a group. The component maintains synchronized state between the select-all functionality and individual items.
## Validation
The Checklist supports form validation through the `<Checklist.ErrorMessage>` component. When rendered, it indicates an invalid state for the checklist group.
<Showcase name="select-all" />
The error message can be used to display validation feedback when:
- Required selections are not met
- The number of selected items is invalid
- Any other group-level validation rules are violated
This validation system allows integration with any form validation library while maintaining the component's accessibility and state management features.
Note: The examples provided focus on basic usage and select-all functionality. For specific form validation examples, please refer to your preferred form validation library's documentation.Looking through the provided examples and implementation, I don't see any environment-specific examples (like CSR vs SSR) or environment-specific features that need to be documented separately.
The examples provided ("hero" and "select-all") demonstrate basic usage patterns and state management, but don't showcase any environment-specific behaviors or rendering cases.
Since there are no environment-specific examples or features to document, I'll leave this section empty in accordance with the strict rules provided.
If environment-specific examples or features are added in the future (such as SSR behavior, hydration patterns, or platform-specific considerations), they should be documented here.

---

# Scroll Area
A customizable container that adds scrollbars when content overflows its boundaries.
<Showcase name="both" />
## Features
<Features api={api} />
## Anatomy 
<AnatomyTable api={api} />
## Examples
### Basic Usage
The scroll area provides a clean way to handle content overflow with customizable scrollbars. The basic setup includes a root component, viewport, and scrollbars.
<Showcase name="vertical" />
The example demonstrates:
- `ScrollArea.Root` as the container
- `ScrollArea.Viewport` wrapping the content
- `ScrollArea.Scrollbar` with `orientation="vertical"` for vertical scrolling
- `ScrollArea.Thumb` for the draggable scrollbar handle
### Visual Features
#### Horizontal Scrolling
For content that extends beyond the horizontal bounds, add a horizontal scrollbar.
<Showcase name="horizontal" />
This example shows:
- `ScrollArea.Scrollbar` with `orientation="horizontal"` 
- Automatic thumb sizing based on content width
- Smooth horizontal scrolling behavior
#### Both Scrollbars
When content overflows in both directions, you can combine vertical and horizontal scrollbars.
<Showcase name="both" />
This setup demonstrates:
- Multiple `ScrollArea.Scrollbar` components
- Independent vertical and horizontal scrolling
- Automatic corner handling where scrollbars meet
### Advanced Usage
#### Scrollbar Visibility Control
The scroll area supports different visibility modes through the `type` prop on `ScrollArea.Root`.## Component State
### Internal State Structure
The ScrollArea component maintains several key state values through Qwik signals:
```typescript
// Core state signals
const viewportRef = useSignal<HTMLDivElement>();
const verticalScrollbarRef = useSignal<HTMLDivElement>();
const horizontalScrollbarRef = useSignal<HTMLDivElement>(); 
const rootRef = useSignal<HTMLDivElement>();
const thumbRef = useSignal<HTMLDivElement>();
const isScrolling = useSignal(false);
const isHovering = useSignal(false);
const scrollTimeout = useSignal<number>();
const hasOverflow = useSignal(false);
```
These signals form the foundation of the ScrollArea's state management:
- `hasOverflow`: Tracks whether content exceeds viewport dimensions
- `isScrolling`: Indicates active scrolling state
- `isHovering`: Tracks mouse hover state
- `scrollTimeout`: Manages scrollbar hide delay timing
### State Updates
The ScrollArea implements several state update patterns:
1. Overflow Detection:
```typescript
const updateOverflow = $((viewport: HTMLElement) => {
  const hasVerticalOverflow = viewport.scrollHeight > viewport.clientHeight;
  const hasHorizontalOverflow = viewport.scrollWidth > viewport.clientWidth;
  context.hasOverflow.value = hasVerticalOverflow || hasHorizontalOverflow;
});
```
2. Scroll State Management:
```typescript
if (context.type === "scroll") {
  context.isScrolling.value = true;
  clearTimeout(context.scrollTimeout.value);
  context.scrollTimeout.value = setTimeout(() => {
    context.isScrolling.value = false;
  }, context.hideDelay);
}
```
3. Hover State:
```typescript
const onMouseEnter$ = $(() => {
  if (type === "hover") {
    isHovering.value = true;
  }
});
const onMouseLeave$ = $(() => {
  if (type === "hover") {
    isHovering.value = false;
  }
});
```
4. Drag State:
```typescript
const isDragging = useSignal(false);
const dragData = useSignal({
  startClientY: 0,
  startClientX: 0,
  startScrollTop: 0,
  startScrollLeft: 0,
  activeThumb: null,
  activeScrollbar: null
});
```
The state updates are triggered by:
- Scroll events
- Mouse interactions
- Window resize
- Zoom level changes
- Content overflow changes
State visibility is determined by the `type` prop:
- `"hover"`: Shows scrollbars on hover when content overflows
- `"scroll"`: Shows scrollbars during active scrolling
- `"auto"`: Shows scrollbars when content overflows
- `"always"`: Always shows scrollbars when content overflows
<Showcase name="both" />
In this example, both vertical and horizontal scrollbars are shown, demonstrating how the component manages multiple scrollbar states simultaneously.Based on the provided examples and API documentation, I'll write about the ScrollArea configuration options.
## Scrollbar Visibility
### Core Behavior
The ScrollArea component supports four visibility modes controlled by the `type` prop on `ScrollArea.Root`:
- `hover` (default): Shows scrollbars when hovering over the scroll area
- `scroll`: Shows scrollbars during scrolling
- `auto`: Shows scrollbars when content overflows
- `always`: Shows scrollbars whenever content overflows
As shown in the `hover-test` example above, scrollbars appear on hover and hide when the mouse leaves the scroll area.
### Hide Delay
When using `type="scroll"`, you can customize how long scrollbars remain visible after scrolling stops using the `hideDelay` prop:
```typescript
type ScrollAreaRootProps = {
  hideDelay?: number; // milliseconds
}
```
The default delay is 600ms. As shown in the `custom-delay-test` example above, you can extend this delay to 1000ms for better visibility.
## Scrollbar Orientation
### Basic Configuration
ScrollArea supports both vertical and horizontal scrollbars through the `orientation` prop on `ScrollArea.Scrollbar`:
```typescript
type ScrollBarProps = {
  orientation: "vertical" | "horizontal";
}
```
As shown in the `both` example above, you can include both orientations simultaneously for content that overflows in both directions.
### Overflow Detection
The component automatically detects content overflow and updates scrollbar visibility accordingly. This behavior is demonstrated in all examples but is particularly visible in the `auto-test` example where scrollbars only appear when content exceeds the viewport dimensions.
Key technical considerations:
- Overflow detection is responsive to window resize events
- Browser zoom level changes trigger overflow recalculation
- The component maintains proper thumb positioning during scroll events
- Scrollbar visibility updates are debounced for performance
> Note: The overflow detection system works with dynamic content and responds to DOM mutations that affect content size.Looking through the provided examples and implementation, I don't see any specific form-related examples or functionality for the ScrollArea component. The ScrollArea component is primarily focused on providing scrollable content areas with customizable scrollbars, rather than form integration.
The component doesn't include:
- Form field integration
- Form validation features
- Form submission handling
- Form state management
Therefore, there is no form-specific configuration section needed for this component.
If you need form functionality, you would need to place form elements inside the ScrollArea's viewport, but the ScrollArea itself doesn't provide any direct form integration features.Looking through the examples provided, I don't see any environment-specific examples (like CSR vs SSR, platform-specific behavior, or environmental dependencies) that would warrant documentation in this section.
The provided examples (`both`, `horizontal`, `vertical`) demonstrate basic usage patterns and different scrollbar orientations, but they don't specifically address environment-related concerns.
Since there are no environment-specific examples or features to document, I'll leave this section empty to avoid creating unnecessary documentation that might confuse users.
If environment-specific examples are added in the future (such as SSR behavior, hydration patterns, or platform-specific implementations), they should be documented here.

---

# Scroll Area
A customizable container that adds scrollbars when content overflows its boundaries.
<Showcase name="both" />
## Features
<Features api={api} />
## Anatomy 
<AnatomyTable api={api} />
## Examples
### Basic Usage
The scroll area component provides a customizable scrolling experience with different visibility modes for the scrollbars.
<Showcase name="vertical" />
The `type` prop controls when scrollbars are visible:
- `"hover"` (default): Shows scrollbars when hovering over the content
- `"scroll"`: Shows scrollbars during scrolling
- `"auto"`: Shows scrollbars when content overflows
- `"always"`: Shows scrollbars whenever content overflows
The `hideDelay` prop (default: 600ms) determines how long scrollbars remain visible after scrolling stops when `type="scroll"`.
### Visual Features
#### Horizontal Scrolling
For content that overflows horizontally, use the `orientation="horizontal"` prop on `ScrollArea.Scrollbar`.
<Showcase name="horizontal" />
#### Both Axes Scrolling
When content overflows in both directions, you can include both vertical and horizontal scrollbars.
<Showcase name="both" />
### Advanced Usage
#### Custom Hide Delay
You can customize how long scrollbars remain visible after scrolling by adjusting the `hideDelay` prop.## Component State
Let's explore how the ScrollArea component manages its internal state and updates.
### Internal State Structure
The ScrollArea uses several key state values managed through Qwik signals:
```typescript
// Core state signals
const viewportRef = useSignal<HTMLDivElement>();
const verticalScrollbarRef = useSignal<HTMLDivElement>();
const horizontalScrollbarRef = useSignal<HTMLDivElement>();
const rootRef = useSignal<HTMLDivElement>();
const thumbRef = useSignal<HTMLDivElement>();
const isScrolling = useSignal(false);
const isHovering = useSignal(false);
const scrollTimeout = useSignal<number>();
const hasOverflow = useSignal(false);
```
These signals form the foundation of the ScrollArea's state management:
- `hasOverflow`: Tracks whether content exceeds viewport dimensions
- `isScrolling`: Indicates active scrolling state
- `isHovering`: Manages hover state for scrollbar visibility
- Element refs: Store references to DOM elements for position calculations
### State Updates
The ScrollArea implements several state update patterns:
1. **Overflow Detection**
```typescript
const updateOverflow = $((viewport: HTMLElement) => {
  const hasVerticalOverflow = viewport.scrollHeight > viewport.clientHeight;
  const hasHorizontalOverflow = viewport.scrollWidth > viewport.clientWidth;
  context.hasOverflow.value = hasVerticalOverflow || hasHorizontalOverflow;
});
```
2. **Scrollbar Visibility Logic**
```typescript
const shouldShow = () => {
  const hasOverflow = context.hasOverflow.value;
  switch (context.type) {
    case "always":
      return hasOverflow;
    case "hover":
      return context.isHovering.value && hasOverflow;
    case "scroll":
      return context.isScrolling.value && hasOverflow;
    case "auto":
      return hasOverflow;
    default:
      return false;
  }
};
```
3. **Scroll State Management**
For `type="scroll"` mode, the component manages scroll visibility with a timer:
```typescript
if (context.type === "scroll") {
  context.isScrolling.value = true;
  clearTimeout(context.scrollTimeout.value);
  context.scrollTimeout.value = setTimeout(() => {
    context.isScrolling.value = false;
  }, context.hideDelay);
}
```
4. **Thumb Position Updates**
The thumb position is updated in response to scroll events:
```typescript
const scrollRatio = viewport.scrollTop / (viewport.scrollHeight - viewport.clientHeight);
const maxTop = verticalScrollbar.clientHeight - verticalThumb.clientHeight;
verticalThumb.style.transform = `translateY(${scrollRatio * maxTop}px)`;
```
5. **Drag State**
The thumb maintains drag state during user interaction:
```typescript
const isDragging = useSignal(false);
const dragData = useSignal({
  startClientY: 0,
  startClientX: 0,
  startScrollTop: 0,
  startScrollLeft: 0,
  activeThumb: null,
  activeScrollbar: null
});
```
This state structure enables smooth scrolling behavior while maintaining proper scroll thumb positioning and visibility states based on user interaction and content overflow conditions.Based on the provided implementation and examples, I'll document the ScrollArea configuration options:
## Scrollbar Visibility
### Visibility Modes
The ScrollArea component supports four visibility modes controlled by the `type` prop on `ScrollArea.Root`:
- `hover` (default): Shows scrollbars when hovering over the scroll area
- `scroll`: Displays scrollbars during scrolling, hiding after `hideDelay`
- `auto`: Always shows scrollbars when content overflows
- `always`: Permanently displays scrollbars when content overflows
As shown in the `hover-test` example above, the scrollbars appear on hover and hide when the mouse leaves.
### Hide Delay Configuration
When using `type="scroll"`, you can customize how long scrollbars remain visible after scrolling stops using the `hideDelay` prop:
```typescript
type ScrollAreaRootProps = {
  hideDelay?: number; // milliseconds, defaults to 600
}
```
As shown in the `custom-delay-test` example above, setting a longer delay keeps the scrollbars visible for an extended period.
## Scrollbar Orientation
### Two-Axis Scrolling
The ScrollArea supports both vertical and horizontal scrollbars simultaneously. As shown in the `both` example above, you can include both orientations by adding two `ScrollArea.Scrollbar` components with different `orientation` props.
### Single Axis Configuration
For content that only needs one scrollbar:
- Vertical scrolling: As shown in the `vertical` example above
- Horizontal scrolling: As shown in the `horizontal` example above
The orientation is controlled through the `orientation` prop on `ScrollArea.Scrollbar`:
```typescript
type ScrollbarOrientation = {
  orientation?: "vertical" | "horizontal"; // defaults to "vertical"
}
```
## Technical Constraints
### Overflow Detection
The ScrollArea automatically detects content overflow and updates scrollbar visibility accordingly. This includes:
- Initial mount
- Window resize
- Zoom level changes
- Dynamic content updates
### Browser Support
The component handles various browser-specific behaviors:
- Cross-browser zoom detection using ctrl/cmd + +/- shortcuts
- Responsive to window resize events
- Maintains scroll position during thumb dragging across browsers
### Performance Considerations
- Scrollbar visibility updates are debounced during scroll events
- Thumb position calculations are optimized for smooth scrolling
- DOM updates are batched for better performanceBased on the provided examples and API documentation, there are no form-specific features or examples for the ScrollArea component. The component is focused on providing scrollable content areas with customizable scrollbar behavior, but does not include any form integration, validation, or submission functionality.
The examples provided (`both`, `horizontal`, `vertical`) demonstrate the basic usage and layout configurations of the ScrollArea component, but none are related to form functionality.
Since there are no form-specific features to document, this section can be skipped.Looking through the provided examples and implementation, I don't see any specific environment-related examples (like CSR vs SSR) or environment-specific features that need to be documented separately.
The ScrollArea component appears to work consistently across environments, with its core functionality of handling scrollable content and custom scrollbars being environment-agnostic. The examples provided (`both`, `horizontal`, `vertical`) demonstrate basic usage patterns rather than environment-specific behaviors.
The component handles client-side interactions like scrolling, dragging, and overflow detection through standard browser APIs, but these are fundamental to the component's functionality rather than environment-specific features.
Since there are no distinct environment-specific examples or features to document, this section can be omitted to avoid redundancy with the basic usage documentation.

---

# Scroll Area
A customizable container that adds scrollbars when content overflows its boundaries.
<Showcase name="both" />
## Features
<Features api={api} />
## Anatomy 
<AnatomyTable api={api} />
## Examples
### Basic Usage
The scroll area component provides a customizable scrolling experience with different visibility modes for the scrollbars.
The `type` prop controls when scrollbars are visible:
- `"hover"` (default): Shows scrollbars on hover
- `"scroll"`: Shows scrollbars during scrolling
- `"auto"`: Shows scrollbars when content overflows
- `"always"`: Shows scrollbars whenever there's overflow
<Showcase name="vertical" />
### Visual Features
#### Horizontal Scrolling
For content that extends beyond the horizontal bounds, use the `orientation="horizontal"` prop on `ScrollArea.Scrollbar`.
<Showcase name="horizontal" />
#### Both Axes Scrolling
When content overflows in both directions, you can include both vertical and horizontal scrollbars.
<Showcase name="both" />
### Advanced Usage
#### Custom Hide Delay
For scroll-triggered visibility (`type="scroll"`), customize how long scrollbars remain visible after scrolling stops using the `hideDelay` prop (in milliseconds).
<Showcase name="both" />
Note: The examples demonstrate the core functionality of the scroll area component. The `hideDelay` prop (default: 600ms) determines how long scrollbars remain visible after scrolling stops when using `type="scroll"`.## Component State
The ScrollArea component offers several ways to control its scrollbar visibility and behavior through state management.
### Using Component State
#### Scrollbar Visibility Types
The ScrollArea provides four visibility modes controlled through the `type` prop on `ScrollArea.Root`:
1. **Auto Mode**
Shows scrollbars when content overflows and hides them when it doesn't.
<Showcase name="both" />
2. **Always Mode**
Keeps scrollbars visible whenever content overflows, regardless of user interaction.
3. **Hover Mode**
Shows scrollbars only when the user hovers over the scroll area.
4. **Scroll Mode**
Displays scrollbars only during active scrolling.
#### Hide Delay Configuration
When using the "scroll" visibility type, you can customize how long the scrollbars remain visible after scrolling stops using the `hideDelay` prop:
```tsx
<ScrollArea.Root type="scroll" hideDelay={1000}>
  {/* Content */}
</ScrollArea.Root>
```
### State Interactions
#### Overflow Detection
The ScrollArea automatically detects content overflow and updates its state accordingly. This state is reflected through the `data-has-overflow` attribute on the root element.
#### Scrollbar State
Scrollbars expose their current visibility state through the `data-state` attribute, which can be either "visible" or "hidden". This state updates automatically based on:
- The chosen visibility type
- Content overflow status
- User interactions (hover, scroll)
- Window resize events
- Zoom level changes
#### Thumb Position
The thumb position automatically updates to reflect the current scroll position. You can programmatically control the scroll position through the viewport:
```tsx
const viewport = document.querySelector('[data-qds-scroll-area-viewport]');
if (viewport) {
  viewport.scrollTop = 100; // Scroll vertically
  viewport.scrollLeft = 50; // Scroll horizontally
}
```
#### Drag State
During thumb dragging, the thumb element receives a `data-dragging` attribute that can be used for styling:
```css
[data-qds-scroll-area-thumb][data-dragging] {
  /* Styles for dragging state */
}
```
The ScrollArea maintains the scroll position relative to the drag position, ensuring smooth scrolling even when the cursor moves outside the scrollbar bounds.Based on the provided implementation and examples, I'll document the ScrollArea configuration options:
## Scrollbar Visibility
### Core Behavior
The ScrollArea component supports four visibility modes controlled by the `type` prop on `ScrollArea.Root`:
- `hover` (default): Shows scrollbars when hovering over the scroll area
- `scroll`: Displays scrollbars during scrolling, then hides after delay
- `auto`: Always shows scrollbars when content overflows
- `always`: Permanently displays scrollbars when content overflows
As shown in the `hover-test` example above, the hover mode provides a clean interface that reveals scrollbars only when needed.
### Hide Delay
For the `scroll` type, you can customize how long scrollbars remain visible after scrolling stops using the `hideDelay` prop:
```typescript
type ScrollAreaRootProps = {
  hideDelay?: number; // milliseconds, defaults to 600
}
```
As shown in the `custom-delay-test` example above, this allows fine-tuning of the scrollbar fade-out timing.
## Scrollbar Configuration
### Orientation Support
ScrollArea supports both vertical and horizontal scrollbars through the `orientation` prop on `ScrollArea.Scrollbar`:
```typescript
type ScrollbarOrientation = "vertical" | "horizontal";
```
As shown in the `both` example above, you can include both orientations simultaneously for content that overflows in both directions.
### Technical Constraints
- Scrollbar visibility is automatically managed based on content overflow
- Thumb size and position are dynamically calculated based on viewport and content dimensions
- Scrollbars maintain position during window resize and zoom operations
- Custom scroll behavior is preserved across browser zoom levels (25% to 500%)
### Performance Considerations
The ScrollArea implements several optimizations:
- Throttled resize handling to prevent excessive recalculation
- Efficient thumb position updates using transform
- Minimal DOM updates during scroll operations
- Lazy initialization of overflow detection
These ensure smooth scrolling performance even with large content areas and frequent updates.Based on the provided examples and API documentation, I don't see any form-specific examples or functionality in the ScrollArea component. The component is focused on providing scrollable content areas with customizable scrollbars, but does not include any form integration features.
The examples provided (`both`, `horizontal`, `vertical`) demonstrate the basic usage and layout configurations of the ScrollArea component, but none of them show form-specific implementations.
Since there are no form-related features or examples to document, this section can be skipped.
The ScrollArea component is primarily used for:
- Content overflow management
- Custom scrollbar visualization
- Scroll behavior control
- Viewport management
But it does not include form-specific functionality like:
- Form field integration
- Form validation
- Form submission handling
- Form state managementLooking through the provided examples and implementation, I don't see any environment-specific examples (like CSR vs SSR) or features that would require special documentation about the environment.
The examples provided (`both`, `horizontal`, `vertical`) demonstrate different scrollbar orientations and basic usage patterns, but don't showcase any environment-specific behavior.
The ScrollArea component appears to work consistently across different rendering environments without requiring special consideration for server vs client rendering or platform-specific behavior.
Therefore, I'll skip this section as per rule #5: "Skip this section entirely if no environment-specific features exist."
If you'd like to document environment-specific features, you would need examples that demonstrate:
- Server-side rendering specific behavior
- Client-side rendering specific behavior
- Platform-specific implementations
- Special rendering cases

---

# Calendar
A customizable date picker that helps users select dates through an intuitive grid interface.
<Showcase name="hero" />
## Features
<Features api={api} />
## Anatomy 
<AnatomyTable api={api} />
## Examples
### Basic Usage
The calendar component provides a simple way to implement date selection functionality. The example below shows the basic setup with core components and date change handling.
<Showcase name="hero" />
This example demonstrates:
- Using `Calendar.Root` as the main container with `locale` set to "en" by default
- `Calendar.Header` containing navigation buttons and month/year display
- `Calendar.Grid` for the calendar layout with `Calendar.GridDay` for individual date cells
- Date selection handling through `onDateChange$` prop
- Visual feedback for selected dates using `data-selected` and current date with `data-current`
Key props used:
- `onDateChange$`: Callback fired when a date is selected
- `data-selected`: Indicates the currently selected date
- `data-current`: Highlights the current date
- `class`: Custom styling applied to various components
The calendar supports full keyboard navigation and follows WAI-ARIA calendar design patterns for accessibility.
Note: Since there are no additional examples available in the provided list, I cannot document other sections like Visual Features or Advanced Usage. The documentation is limited to the basic usage example shown in the hero showcase.## Component State
### Using Component State
The Calendar component's state can be controlled through several props on the `Calendar.Root` component:
1. **Default Date**
Set the initial date to display when the calendar loads using the `defaultDate` prop:
```tsx
<Calendar.Root defaultDate="2024-03-15">
  {/* Calendar content */}
</Calendar.Root>
```
2. **Selected Date**
Track the currently selected date using the `date` prop:
```tsx
<Calendar.Root date={selectedDate}>
  {/* Calendar content */}
</Calendar.Root>
```
3. **Display Options**
Control what information is shown in the calendar:
```tsx
<Calendar.Root 
  showWeekNumber={true}  // Show week numbers
  showDaysOfWeek={true}  // Show day names header
  fullWeeks={true}       // Show complete weeks including adjacent month days
>
  {/* Calendar content */}
</Calendar.Root>
```
### State Interactions
The Calendar provides ways to respond to date selection through event handlers:
1. **Date Selection**
Listen for date changes using the `onDateChange$` prop on either the `Calendar.Root` or `Calendar.GridDay` components:
```tsx
<Calendar.Root
  onDateChange$={(date) => {
    console.log('Selected date:', date);
  }}
>
  {/* Calendar content */}
</Calendar.Root>
```
As shown in the hero example, you can track the selected date in your application state:
```tsx
const selectedDate = useSignal<LocalDate>();
<Calendar.GridDay
  onDateChange$={$((date) => {
    selectedDate.value = date;
  })}
/>
```
2. **Popover State**
Control the calendar popover's open state using the `bind:open` prop:
```tsx
const isOpen = useSignal(false);
<Calendar.Root bind:open={isOpen}>
  {/* Calendar content */}
</Calendar.Root>
```
The calendar component maintains its own internal state for:
- Current month/year being displayed
- Date currently in focus
- Navigation between months
- Keyboard navigation within the calendar grid
These aspects are handled automatically by the component and don't require manual management.Based on the provided implementation and examples, I'll document the Calendar component's configuration options.
## Core Configuration
### Locale and Date Format
The Calendar component supports localization through the `locale` prop on `Calendar.Root`. Currently, it supports:
- Default locale: `"en"`
- Date format: `YYYY-MM-DD`
As shown in the hero example above, the calendar uses the default English locale for month names, weekday labels, and date formatting.
### Initial Date Selection
The calendar can be configured with:
- `defaultDate`: Sets the initial focused date (defaults to current date)
- `date`: Controls the currently selected date
- `showDaysOfWeek`: Controls visibility of weekday headers (defaults to `true`)
- `showWeekNumber`: Enables week number display (defaults to `false`)
### Week Display
The calendar provides two week display modes controlled by the `fullWeeks` prop:
```typescript
type WeekDisplayProps = {
  // When true, shows complete weeks including days from adjacent months
  fullWeeks?: boolean; // default: false
}
```
## Advanced Configuration
### Date Change Handling
The calendar supports date selection handling through:
```typescript
type DateChangeProps = {
  onDateChange$?: (date: LocalDate) => void;
}
```
Where `LocalDate` is typed as:
```typescript
type LocalDate = `${number}-${number}-${number}`;
```
### Grid Customization
The calendar grid can be customized through:
- `buttonProps`: Props to be spread onto each date button
- Custom day cell rendering through `Calendar.GridDay`
### Technical Constraints
1. Date Format Validation
   - Dates must follow the `YYYY-MM-DD` format
   - Invalid formats will throw an error during initialization
2. Month Navigation
   - Month navigation is handled internally
   - Year boundaries are automatically managed when navigating between December and January
3. Focus Management
   - Focus is automatically managed within the calendar grid
   - Only one date cell is focusable at a time (tabIndex management)
   - Focus is preserved during month navigation
The calendar maintains internal state for:
- Current month/year being displayed
- Selected date
- Focused date
- Week number calculations (when enabled)Based on the provided examples and API documentation, I don't see any form-specific examples or functionality for the Calendar component. The only example provided (`hero`) demonstrates basic date selection functionality but does not show form integration, validation, or submission.
The Calendar component appears to be focused on date selection and navigation rather than form functionality. While it does emit selected dates through the `onDateChange$` handler, there are no specific form integration features shown in the examples or API documentation.
If form integration examples are added in the future, they should be documented here to explain how the Calendar component can be used within forms, including:
- Form field integration
- Validation states
- Form submission handling
- Integration with form libraries
For now, this section can be skipped as there are no form-specific features to document.Based on the provided examples and component implementation, I don't see any environment-specific examples (like CSR vs SSR) or features that would require special documentation about the component's environment.
The example provided (`hero`) demonstrates basic calendar functionality but doesn't showcase any environment-specific behavior.
Since there are no environment-specific examples or features to document, this section should be omitted to maintain documentation clarity and avoid redundancy.
If future examples demonstrate environment-specific behaviors like:
- Server vs client rendering differences
- Platform-specific behaviors
- Environmental dependencies
- Special rendering cases
Then this section should be updated accordingly.

---

# Checklist
A group of selectable items that can be toggled individually or all at once.
<Showcase name="hero" />
## Features
<Features api={api} />
## Anatomy
<AnatomyTable api={api} />
## Examples
### Basic Usage
The basic checklist setup allows users to select multiple items independently.
<Showcase name="select-all" />
This example demonstrates:
- `Checklist.Root` as the container for all checklist items
- `Checklist.Item` for individual selectable items
- `Checklist.ItemTrigger` and `Checklist.ItemIndicator` for the checkbox interaction
- `Checklist.ItemLabel` for item text
- `Checklist.SelectAll` for the parent checkbox that controls all items
- `Checklist.SelectAllIndicator` showing the mixed state with both check and minus icons
- `Checklist.Label` for the select all text
The select-all functionality automatically manages three states:
- Unchecked when no items are selected
- Mixed state when some items are selected
- Checked when all items are selected
Each item maintains its own state while staying synchronized with the select-all checkbox.
Note: The example uses Lucide icons (`LuCheck` and `LuMinus`) to display the checkbox states, but you can customize these with your own icons or indicators.## Component State
### Using Component State
The Checklist component provides a powerful way to manage multiple checkbox selections with a "select all" capability. Let's look at how to implement and control the checklist state.
The basic checklist state is demonstrated in the hero example:
<Showcase name="hero" />
For more advanced state management, including a "select all" feature:
<Showcase name="select-all" />
This example demonstrates:
- Individual item selection state
- Select all functionality
- Mixed state when only some items are selected
### State Interactions
The checklist maintains three main states:
- Unchecked: No items selected
- Mixed: Some items selected
- Checked: All items selected
The select-all checkbox automatically updates based on the state of individual items:
- Shows unchecked when no items are selected
- Shows a mixed state when some items are selected
- Shows checked when all items are selected
To respond to state changes, the checklist items and select-all checkbox are automatically synchronized:
1. When clicking the select-all checkbox:
   - If unchecked: All items become checked
   - If checked or mixed: All items become unchecked
2. When clicking individual items:
   - Updates the select-all checkbox state based on overall selection
   - Maintains the mixed state when appropriate
The state management is handled automatically by the component, requiring no additional configuration from the user. Simply structure your checklist with the appropriate components and the state synchronization works out of the box.Based on the provided implementation and examples, I'll document the configuration options for the Checklist component.
## Core Configuration
### Select All Behavior
The Checklist component supports a "select all" functionality that manages the state of all child checkboxes. As shown in the `select-all` example above, this requires configuring both the select all trigger and individual items.
The select all state automatically manages three possible values:
- `false` - No items checked
- `true` - All items checked  
- `"mixed"` - Some items checked
### Item Management
Items must be direct children of `Checklist.Root` to be properly tracked. The component internally manages indices for state synchronization.
> Each `Checklist.Item` requires a unique key when mapping over items to maintain proper state tracking.
### Group Configuration
The Checklist is configured as a checkbox group by default with the following characteristics:
```typescript
type ChecklistContext = {
  isAllCheckedSig: Signal<boolean | "mixed">;
  checkedStatesSig: Signal<(boolean | "mixed")[]>;
};
```
The context manages:
- Overall checked state (`isAllCheckedSig`)
- Individual item states (`checkedStatesSig`)
### Form Integration
The Checklist can be integrated with forms through the `HiddenInput` component. As shown in the `hero` example above, this manages the form submission state for all checkboxes in the group.
## Advanced Configuration
### State Synchronization
The Checklist implements a bi-directional state synchronization:
1. Select All → Items:
- When select all is toggled, all items update to match
- Mixed state is preserved when partially selected
2. Items → Select All:
- Select all updates based on collective item state
- Automatically switches to mixed state when appropriate
### Custom Layouts
While the component handles state management, the layout is fully customizable. As shown in the `select-all` example above, items can be nested and grouped with custom spacing and hierarchies.
> Note: The internal state tracking works regardless of DOM structure, but items must remain direct children of `Checklist.Root` in the component tree.Based on the provided implementation and examples, I'll document the form-specific features of the Checklist component.
## Forms
The Checklist component provides form integration through the `<Checklist.HiddenInput>` component, which manages multiple checkbox form inputs.
The component follows a group pattern where the select-all functionality can control multiple checkbox states simultaneously.
<Showcase name="select-all" />
In this example, the select-all checkbox controls the state of all child checkboxes, maintaining form state synchronization. When some items are selected, the select-all checkbox displays a mixed state, indicated by the minus icon.
The form state is managed through the `ChecklistContext`, which tracks:
- The overall checked state (`isAllCheckedSig`)
- Individual item states (`checkedStatesSig`)
The `<Checklist.Root>` component acts as a form group container with the appropriate `role="group"` attribute, ensuring proper form semantics and accessibility.
Note: The current implementation doesn't show explicit form validation examples, but the component structure includes `<Checklist.ErrorMessage>` for handling validation states when needed.Looking through the provided examples and implementation, I don't see any environment-specific examples (like CSR vs SSR) or environment-specific features that need to be documented separately.
The examples provided ("hero" and "select-all") demonstrate basic usage patterns and state management functionality, but don't showcase any environment-specific behaviors or rendering cases.
Since there are no environment-specific examples or features to document, I'll leave this section empty to avoid duplicating information that belongs in other sections of the documentation.

---

# File Upload
A drag and drop interface for uploading files with support for filtering and multiple selections.
<Showcase name="hero" />
## Features
<Features api={api} />
## Anatomy
<AnatomyTable api={api} />
## Examples
### Basic Usage
The most basic implementation allows users to upload files through drag and drop or button click.
### Visual Features
The file upload component can be styled to match your application's design.
### Advanced Usage
#### Multiple File Upload
Enable multiple file selection and handle batch uploads.
#### Disabled State
The file upload can be disabled to prevent user interaction.## Component State
### Using Component State
The File Upload component's state can be controlled through several key props on the `FileUpload.Root` component:
1. **Multiple File Selection**
Enable multiple file selection using the `multiple` prop:
```tsx
<FileUpload.Root 
  multiple 
  onFilesChange$={(files) => {
    // Handle multiple files
  }}
>
```
2. **File Type Filtering**
Restrict file types using the `accept` prop:
```tsx
<FileUpload.Root 
  accept="image/*" 
  onFilesChange$={(files) => {
    // Handle image files only
  }}
>
```
3. **Disabled State**
Disable the entire upload functionality using the `disabled` prop:
```tsx
<FileUpload.Root disabled>
  {/* All child components will be disabled */}
</FileUpload.Root>
```
### State Interactions
The File Upload component provides a comprehensive callback system to handle file changes:
1. **File Change Events**
The `onFilesChange$` prop allows you to respond to file selections:
```tsx
<FileUpload.Root
  onFilesChange$={(files) => {
    // files is an array of FileInfo objects:
    // {
    //   name: string;
    //   size: number;
    //   type: string;
    //   lastModified: number;
    //   file: File;
    // }
    // Process files
    files.forEach(fileInfo => {
      const formData = new FormData();
      if (fileInfo.file) {
        formData.append('file', fileInfo.file);
        // Upload to server
      }
    });
  }}
>
```
2. **Drag State**
The component automatically manages drag states and provides visual feedback through data attributes:
- `data-dragging`: Present when files are being dragged over the dropzone
- `data-disabled`: Present when the component is disabled
These attributes can be used for styling:
```css
[data-file-upload-dropzone][data-dragging] {
  border-color: blue;
}
[data-file-upload-dropzone][data-disabled] {
  opacity: 0.5;
}
```
The state management is demonstrated in the examples:
- Basic file upload with single file selection: <Showcase name="hero" />Based on the provided examples and API documentation, I'll document the configuration options for the File Upload component.
## Core Configuration
### File Selection Mode
The File Upload component supports both single and multiple file selection modes through the `multiple` prop on `FileUpload.Root`.
As shown in the hero example above, by default, the component operates in single file mode. To enable multiple file selection, add the `multiple` prop to `FileUpload.Root`.
> The `multiple` prop is `false` by default, allowing only single file selection.
### File Type Filtering
The component supports file type filtering through the `accept` prop on `FileUpload.Root`. This allows you to restrict which file types users can select.
As shown in the hero example above, you can use MIME types or file extensions to filter files:
> Common accept values:
> - `"image/*"` - All image types
> - `".pdf,.doc,.docx"` - Specific file extensions
> - `"video/*,audio/*"` - Multiple MIME types
### Disabled State
The File Upload component can be disabled entirely using the `disabled` prop on `FileUpload.Root`. When disabled:
- The trigger button becomes unclickable
- The file input is disabled
- Drag and drop functionality is prevented
- Visual feedback indicates the disabled state
## Advanced Configuration
### File Change Handling
The component provides detailed file information through the `onFilesChange$` callback prop on `FileUpload.Root`. The callback receives an array of `FileInfo` objects with the following structure:
```typescript
interface FileInfo {
  name: string;
  size: number;
  type: string;
  lastModified: number;
  file: NoSerialize<File>;
}
```
> The `file` property is wrapped in `NoSerialize` to prevent serialization issues in Qwik's resumability model.
### Drag and Drop Behavior
The component automatically handles drag and drop events and provides visual feedback through data attributes:
```typescript
interface DropzoneAttributes {
  "data-dragging": string | undefined;  // Present when files are being dragged over
  "data-disabled": string | undefined;  // Present when the dropzone is disabled
}
```
These attributes can be used for styling and state management in more complex implementations.Looking through the examples and implementation, I can see this is a file upload component that can be integrated with forms. Let me document the form-specific features:
## Forms
The FileUpload component can be integrated with forms by handling the uploaded files in the `onFilesChange$` callback. This allows you to process files and submit them using `FormData`.
<Showcase name="hero" />
The callback provides an array of `FileInfo` objects containing the file metadata and the actual `File` object that can be used with `FormData` for form submission.
```tsx
// Example form submission
const formData = new FormData();
if (fileInfo.file) {
  formData.append("file", fileInfo.file);
  // Submit form data
  fetch('/api/upload', {
    method: 'POST', 
    body: formData
  });
}
```
## Validation
The FileUpload component provides built-in file type validation through the `accept` prop on `FileUpload.Root`. This allows you to restrict which file types can be uploaded.
```tsx
// Only allow image files
<FileUpload.Root accept="image/*">
```
The component also supports custom validation through the `onFilesChange$` callback where you can implement additional validation logic:
```tsx
<FileUpload.Root
  onFilesChange$={(files) => {
    // Custom validation
    const validFiles = files.filter(file => {
      return file.size < 5000000; // < 5MB
    });
  }}
>
```
When files are invalid, you can prevent them from being processed and provide feedback to the user through your own UI components.
The disabled state can also be used to prevent file uploads entirely when form conditions are not met:
```tsx
<FileUpload.Root disabled={!isValid}>
```
This provides flexibility in implementing form validation while maintaining a consistent user experience.Looking through the provided examples and implementation, I don't see any environment-specific examples or features that would warrant documentation in this section.
The FileUpload component works consistently across server and client environments without any special considerations. The examples provided focus on basic usage patterns, state management (disabled, multiple files), and styling - none of which are environment-specific concerns.
The component handles:
- File selection via system dialog
- Drag and drop functionality 
- File processing
- State management
- Event handling
But these behaviors are consistent regardless of the rendering environment.
Since there are no environment-specific examples or features to document, this section should be skipped to avoid redundant or irrelevant documentation.

---

# QR Code
Generate scannable codes to share links and information instantly.
<Showcase name="base" />
## Features
<Features api={api} />
## Anatomy
<AnatomyTable api={api} />
## Examples
### Basic Usage
The QR code component provides a simple way to generate scannable codes. The `value` prop specifies the content to encode, while the `level` prop determines error correction strength.
<Showcase name="base" />
Key features demonstrated:
- `value` prop to set the QR code content
- `level="H"` for high error correction
- Basic structure with `Root`, `Frame`, `PatternSvg`, and `PatternPath` components
### Visual Features
#### Custom Colors and Overlay
You can customize the QR code appearance with different colors and add an overlay image in the center.
<Showcase name="overlay-custom-color" />
Key features demonstrated:
- Custom fill color using the `fill` prop on `PatternPath`
- Background styling through CSS classes
- Center overlay with the `Overlay` component
- Custom `aria-label` for accessibility
### Advanced Usage
#### Multiple QR Codes
Display multiple QR codes side by side, each with unique content and styling.
<Showcase name="multiple" />
Key features demonstrated:
- Independent QR codes with different values
- Consistent styling across instances
- Optional overlay support per instance
- Flexible layout arrangement## Component State
### Using Component State
The QR Code component's state can be controlled through two main props on the `QRCode.Root` component:
1. `value` - Sets the text content to be encoded in the QR code
2. `level` - Controls the error correction level ("L", "M", "Q", "H")
Here's how to use these props:
<Showcase name="base" />
In this example, we set:
- `value` prop to "https://qwikui.com" to encode a URL
- `level` prop to "H" for high error correction
### Multiple QR Codes
You can render multiple QR codes with different values on the same page:
<Showcase name="multiple" />
This example demonstrates:
- Creating two QR codes with the same value but different presentations
- One basic QR code and one with an overlay
- Both using high ("H") error correction level
### Custom Styling
The QR code's appearance can be customized through props:
<Showcase name="overlay-custom-color" />
This example shows:
- Setting custom fill color using the `fill` prop on `QRCode.PatternPath`
- Adding custom frame styling through CSS classes
- Including an overlay image while maintaining QR code functionality
The QR code component automatically updates whenever the `value` or `level` props change, ensuring the displayed code always matches the current state.
Note: The component handles all state updates internally - you only need to provide the desired value and error correction level through props.Based on the provided implementation and examples, I'll document the QR code component's configuration options.
## Core Configuration
### QR Code Value and Error Correction
The QR code can be configured through two essential props on the `QRCode.Root` component:
- `value`: The text or URL to encode (string)
- `level`: Error correction level ("L" | "M" | "Q" | "H")
As shown in the `base` example above, these props control the core functionality of the QR code generation.
> The default error correction level is "L" (Low) if not specified.
### Dimensions
The QR code size is controlled through the `width` and `height` attributes on the `QRCode.PatternSvg` component. As demonstrated in all examples above, the standard size is 200x200 pixels.
The QR code automatically adjusts its internal grid size based on:
- Content length
- Error correction level
- Border settings (fixed at 0)
## Advanced Configuration
### Custom Styling
The QR code supports custom colors and styling through two main approaches:
1. Pattern Color: As shown in the `overlay-custom-color` example above, the `fill` attribute on `QRCode.PatternPath` controls the QR code color.
2. Background Color: The `QRCode.Frame` component accepts CSS classes for styling the background and container.
### Overlay Configuration
The `QRCode.Overlay` component supports custom content positioning. As demonstrated in the `overlay` example above, it's commonly used with images but can contain any content.
Technical constraints for overlays:
```typescript
// Recommended overlay image size ratio
const maxOverlaySize = qrCodeSize * 0.375; // 37.5% of QR code size
```
> When using overlays, it's recommended to use a higher error correction level ("H") to ensure readability despite the overlay covering part of the code.
### Multiple Instances
As shown in the `multiple` example above, multiple QR codes can be rendered on the same page. Each instance maintains its own context and state, allowing for different configurations and values.
Technical considerations:
- Each QR code instance creates its own context
- Memory usage scales linearly with the number of instances
- Pattern generation is performed independently for each instanceBased on the provided component implementation and examples, I don't see any form-specific features or examples for the QR Code component. The component is primarily focused on displaying and customizing QR codes rather than form integration.
The available examples (`base`, `multiple`, `overlay-custom-color`, and `overlay`) demonstrate visual customization and display features, but none show form integration, validation, or submission functionality.
Since there are no form-specific features to document, this section can be skipped. The QR Code component is designed to be a display component rather than a form input component.
If form integration becomes a requirement in the future, features like:
- Form field integration
- Value validation
- Form submission handling
- Form state management
would need to be implemented and documented accordingly.Based on the provided examples and implementation, I don't see any environment-specific examples or features that would warrant documentation about server vs. client rendering, platform-specific behavior, environmental dependencies, or special rendering cases.
The examples provided (`base`, `multiple`, `overlay`, and `overlay-custom-color`) demonstrate basic usage patterns, styling variations, and component composition, but don't showcase any environment-specific functionality.
The QR Code component appears to work consistently across environments without any special considerations needed for server-side rendering (SSR) or client-side rendering (CSR).
Therefore, following the strict rules provided, I'll skip this section as no environment-specific features exist in the current implementation.

---

# QR Code
Generate scannable codes to share links and information instantly.
<Showcase name="base" />
## Features
<Features api={api} />
## Anatomy
<AnatomyTable api={api} />
## Examples
### Basic Usage
The QR code component provides a simple way to generate scannable codes. The basic setup requires a `value` prop for the encoded content and an optional `level` prop for error correction.
<Showcase name="base" />
The `value` prop accepts any string to be encoded, while the `level` prop can be set to `"L"`, `"M"`, `"Q"`, or `"H"` for different error correction levels.
### Visual Features
#### Custom Colors and Overlay
You can customize the appearance of your QR code with custom colors and add an overlay image in the center.
<Showcase name="overlay-custom-color" />
The `fill` prop on `QRCode.PatternPath` controls the color of the QR code pattern, while the `QRCode.Overlay` component allows you to place an image or any content on top of the code.
### Advanced Usage
#### Multiple QR Codes
You can render multiple QR codes on the same page, each with unique values and styling.
<Showcase name="multiple" />
Each QR code maintains its own independent state and styling, making it perfect for displaying different encoded values simultaneously.## Component State
### Using Component State
The QR Code component's state can be controlled through two main props on the `QRCode.Root` component:
1. `value` - Sets the text content to be encoded in the QR code
2. `level` - Controls the error correction level ("L", "M", "Q", "H")
Here's how to use these props:
<Showcase name="base" />
In this example, we set:
- `value` prop to "https://qwikui.com" to generate a QR code for the website URL
- `level` prop to "H" for high error correction
### Multiple QR Codes
You can render multiple QR codes with different values on the same page:
<Showcase name="multiple" />
This example demonstrates:
- Creating two QR codes with different values
- Each QR code maintains its own independent state
- Both QR codes can use different error correction levels if needed
### Custom Styling
The QR code's appearance can be customized through props:
<Showcase name="overlay-custom-color" />
This example shows:
- Setting custom colors using the `fill` prop on `QRCode.PatternPath`
- Adding custom styling to the frame through CSS classes
- Maintaining the QR code's functionality while changing its appearance
Note: When customizing colors, ensure sufficient contrast between the QR code pattern and background for reliable scanning.
The state management in the QR code component is designed to be simple and declarative, with changes to the `value` or `level` props automatically updating the rendered QR code pattern.Based on the provided implementation and examples, I'll document the QR code component's configuration options.
## Core Configuration
### Basic Setup
The QR code component requires two essential configurations: `value` and `level` props on the `QRCode.Root` component.
As shown in the `base` example above, the minimal configuration includes:
- `value`: The text or URL to encode
- `level`: Error correction level (`"L"`, `"M"`, `"Q"`, or `"H"`)
> The default error correction level is "L" (Low) if not specified.
### Pattern Size
The QR code pattern size is controlled through the `width` and `height` attributes on the `QRCode.PatternSvg` component. As shown in all examples above, the recommended size is 200x200 pixels for optimal scanning.
> The SVG viewBox is automatically calculated based on the QR code data matrix size.
## Advanced Configuration
### Error Correction Levels
The `level` prop supports four values with different data redundancy capabilities:
```typescript
type ErrorCorrectionLevel = "L" | "M" | "Q" | "H";
```
- `"L"`: Low (7% recovery)
- `"M"`: Medium (15% recovery)
- `"Q"`: Quartile (25% recovery)
- `"H"`: High (30% recovery)
> When using overlays, it's recommended to use `"H"` level as shown in the `overlay` example above to ensure reliable scanning.
### Pattern Customization
The QR code pattern is rendered using SVG paths, allowing for various customizations:
- Zero-border output by default
- Vector-based scaling without quality loss
- Dynamic updates when value changes
- Path-based rendering for better performance
> The component automatically recalculates the pattern when either the `value` or `level` props change.
Technical constraints:
- Minimum QR code version is determined by data length
- Maximum supported data capacity varies by error correction level
- Pattern must maintain sufficient contrast for scanningBased on the provided component implementation and examples, I don't see any form-specific features or examples for the QR Code component. The component is primarily focused on displaying and customizing QR codes rather than form integration.
The available examples (`base`, `multiple`, `overlay-custom-color`, and `overlay`) demonstrate visual customization and display features, but none show form integration, validation, or submission functionality.
Since there are no form-specific features to document, this section can be skipped. The QR Code component is designed to be a display component rather than a form input component.
If form integration becomes a requirement in the future, features like:
- Form field integration
- Value validation
- Form submission handling
- Form state management
would need to be implemented and documented.Based on the provided examples and implementation, I don't see any environment-specific examples or features that would warrant documentation about server vs. client rendering, platform-specific behavior, environmental dependencies, or special rendering cases.
The examples provided (`base`, `multiple`, `overlay`, and `overlay-custom-color`) demonstrate basic usage patterns, styling variations, and component composition, but don't showcase any environment-specific functionality.
The QR Code component appears to work consistently across environments without any special considerations needed for server-side rendering (SSR) or client-side rendering (CSR).
Therefore, following the strict rules provided, I'll skip this section as no environment-specific features exist in the current implementation.

---

# QR Code
Generate scannable codes to share links and information instantly.
<Showcase name="base" />
## Features
<Features api={api} />
## Anatomy
<AnatomyTable api={api} />
## Examples
### Basic Usage
The QR code component provides a simple way to generate scannable codes. The basic setup requires a `value` prop for the encoded content and an optional `level` prop for error correction.
<Showcase name="base" />
The `value` prop accepts any string content, while `level` can be set to `"L"` (Low), `"M"` (Medium), `"Q"` (Quartile), or `"H"` (High) for different levels of error correction.
### Visual Features
#### Custom Colors and Overlay
You can customize the QR code's appearance with custom colors and add an overlay image in the center.
<Showcase name="overlay-custom-color" />
The `fill` prop on `QRCode.PatternPath` controls the QR code color, while `QRCode.Overlay` allows placing an image or content on top of the code. The frame can be styled using CSS classes.
### Advanced Usage
#### Multiple QR Codes
Multiple QR codes can be rendered on the same page, each with unique values and styling.
<Showcase name="multiple" />
Each QR code maintains its own context and can have different values, error correction levels, and visual customizations while coexisting on the same page.## Component State
### Using Component State
The QR code component's state can be controlled through two main props on the `QRCode.Root` component:
1. `value` - Sets the text content to be encoded in the QR code
2. `level` - Controls the error correction level ("L", "M", "Q", "H")
Here's how to use these props:
<Showcase name="base" />
In this example, we set:
- `value` prop to "https://qwikui.com" to encode a URL
- `level` prop to "H" for high error correction
### Multiple QR Codes
You can render multiple QR codes with different values on the same page:
<Showcase name="multiple" />
This example demonstrates:
- Creating two QR codes with the same value but different presentations
- One basic QR code and one with an overlay
- Both using high ("H") error correction level
### Custom Styling
The QR code's appearance can be customized through props:
<Showcase name="overlay-custom-color" />
This example shows:
- Setting custom fill color through the `fill` prop on `QRCode.PatternPath`
- Using custom CSS classes for styling the frame
- Adding an overlay image while maintaining QR code functionality
The component maintains its functionality while allowing visual customization through standard HTML/CSS properties and the component's built-in styling props.
Note: The QR code will automatically update whenever the `value` or `level` props change, ensuring the displayed code always matches the current props.Based on the provided implementation and examples, I'll document the QR code component's configuration options.
## Core Configuration
### Basic Setup
The QR code component requires two essential configurations: `value` and `level` props on the `QRCode.Root` component.
As shown in the `base` example above, the minimal configuration includes:
- `value`: The text or URL to encode
- `level`: Error correction level ("L", "M", "Q", "H")
> The default error correction level is "L" (Low) if not specified.
### Dimensions
The QR code size is controlled through the `width` and `height` props on the `QRCode.PatternSvg` component. As shown in all examples above, the recommended size is 200x200 pixels for optimal scanning.
> The QR code maintains its aspect ratio regardless of the container size.
## Advanced Configuration
### Error Correction Levels
The `level` prop supports four values with different data redundancy capabilities:
```typescript
type ErrorCorrectionLevel = "L" | "M" | "Q" | "H";
```
- L (Low): 7% of data can be restored
- M (Medium): 15% of data can be restored
- Q (Quartile): 25% of data can be restored
- H (High): 30% of data can be restored
As shown in the `overlay` and `overlay-custom-color` examples above, using level "H" is recommended when adding an overlay to ensure reliable scanning.
### Pattern Customization
The QR code pattern is rendered using SVG paths, allowing for color customization through the `fill` attribute on `QRCode.PatternPath`. As demonstrated in the `overlay-custom-color` example above, you can modify the pattern color to match your design requirements.
> The QR code maintains functionality regardless of color choice, but ensure sufficient contrast for reliable scanning.
### Technical Constraints
- The QR code is generated with zero borders by default
- The pattern data is dynamically updated when either `value` or `level` props change
- The SVG viewBox is automatically calculated based on the QR code matrix size
- The component uses the uqr library for encoding, which supports UTF-8 charactersBased on the provided component implementation and examples, I don't see any form-specific features or examples for the QR Code component. The component is primarily focused on displaying and customizing QR codes rather than form integration.
The available examples (`base`, `multiple`, `overlay`, and `overlay-custom-color`) demonstrate visual customization and multiple instance usage, but none of them show form-related functionality.
Since there are no form-specific features such as:
- Form integration
- Form validation
- Form submission
- Form state handling
I'll skip writing the form configuration section for this component as it would not be applicable to its core functionality.
The QR Code component is designed to be a display component rather than a form input component.Based on the provided examples and implementation, I don't see any environment-specific examples or features that would warrant documentation about server vs. client rendering, platform-specific behavior, environmental dependencies, or special rendering cases.
The examples provided (`base`, `multiple`, `overlay`, and `overlay-custom-color`) demonstrate basic usage patterns, styling variations, and component composition, but don't showcase any environment-specific functionality.
The QR Code component appears to work consistently across environments without any special considerations needed for server-side rendering (SSR) or client-side rendering (CSR).
Therefore, following the strict rules provided, I'll skip this section as no environment-specific features exist in the current implementation.

---

# QR Code
Generate scannable codes to share links and information instantly.
<Showcase name="base" />
## Features
<Features api={api} />
## Anatomy
<AnatomyTable api={api} />
## Examples
### Basic Usage
The QR code component provides a simple way to generate scannable codes. The basic setup requires a `value` prop for the encoded content and an optional `level` prop for error correction.
<Showcase name="base" />
The `value` prop accepts any string to be encoded, while `level` determines error correction strength ("L", "M", "Q", "H").
### Visual Features
#### Custom Overlay and Colors
You can customize the QR code appearance with overlays and custom colors. The `QRCode.Overlay` component allows placing images or content on top of the code.
<Showcase name="overlay-custom-color" />
The example demonstrates:
- Custom fill color using the `fill` prop on `QRCode.PatternPath`
- Background styling through CSS classes on `QRCode.Frame`
- Centered overlay image using `QRCode.Overlay`
### Advanced Usage
#### Multiple QR Codes
Multiple QR codes can be rendered on the same page, each with unique values and styling.
<Showcase name="multiple" />
This example shows:
- Independent QR codes with different values
- Separate styling for each instance
- Optional overlay on specific instances
- Flexible layout arrangement using CSS
Each QR code maintains its own context and can be styled independently while remaining scannable.## Component State
### Using Component State
The QR Code component's state can be controlled through two main props on the `QRCode.Root` component:
1. `value` prop - Sets the text content to be encoded in the QR code
2. `level` prop - Controls the error correction level of the QR code
The base example demonstrates the fundamental state usage:
<Showcase name="base" />
In this example, we set:
- `value="https://qwikui.com"` to encode a URL
- `level="H"` for high error correction
### State Interactions
The QR code updates automatically when its props change. You can see this in action with multiple QR codes rendering different values:
<Showcase name="multiple" />
The example above shows two QR codes with different values rendered simultaneously, demonstrating how each instance maintains its own independent state.
For custom styling based on state, you can combine the QR code with custom colors:
<Showcase name="overlay-custom-color" />
This example shows how to:
- Customize the QR code appearance using the `fill` prop on `QRCode.PatternPath`
- Add visual elements using `QRCode.Overlay`
- Maintain the QR code's functionality while applying custom styling
The QR code component is designed to be declarative - simply update the `value` or `level` props, and the component will automatically regenerate the QR code pattern with the new settings.
Note: The QR code supports four error correction levels:
- `"L"` - Low (7% recovery)
- `"M"` - Medium (15% recovery)
- `"Q"` - Quartile (25% recovery)
- `"H"` - High (30% recovery)
Higher error correction levels make the QR code more resistant to damage or obstruction, which is especially important when using overlays or in situations where the code might get partially obscured.Based on the provided implementation and examples, I'll document the QR code component's configuration options.
## Core Configuration
### Basic Setup
The QR code component requires two essential configurations: `value` and `level` props on the `QRCode.Root` component.
As shown in the `base` example above, the minimal configuration includes:
- `value`: The text or URL to encode
- `level`: Error correction level (`"L"`, `"M"`, `"Q"`, or `"H"`)
> The default error correction level is "L" (Low) if not specified.
### Pattern Size
The QR code pattern size is controlled through the `width` and `height` attributes on the `QRCode.PatternSvg` component. As shown in all examples above, the recommended size is 200x200 pixels for optimal scanning.
> The SVG viewBox is automatically calculated based on the QR code data matrix size.
## Advanced Configuration
### Error Correction Levels
The `level` prop supports four values with different data redundancy capabilities:
```typescript
type ErrorCorrectionLevel = "L" | "M" | "Q" | "H";
```
- `"L"`: Low (7% of data can be restored)
- `"M"`: Medium (15% of data can be restored)
- `"Q"`: Quartile (25% of data can be restored)
- `"H"`: High (30% of data can be restored)
As shown in the `overlay` example above, using `"H"` level is recommended when adding an overlay to ensure reliable scanning.
### Pattern Customization
The QR code pattern can be customized through the `PatternPath` component. As shown in the `overlay-custom-color` example above, you can modify the pattern color using the `fill` attribute.
> The QR code maintains its functionality regardless of color, as long as there's sufficient contrast between the pattern and background.
### Technical Constraints
1. Border: The component generates QR codes with zero border padding
2. Data Capacity: Maximum capacity depends on:
   - Error correction level
   - Character encoding
   - QR code version (automatically selected)
> The component automatically selects the optimal QR code version based on the input data and error correction level.Based on the provided component implementation and examples, I don't see any form-specific features or examples for the QR Code component. The component is primarily focused on displaying and customizing QR codes rather than form integration.
The available examples (`base`, `multiple`, `overlay-custom-color`, and `overlay`) demonstrate visual customization and display features, but none show form integration, validation, or submission functionality.
Since there are no form-specific features to document, this section can be skipped. The QR Code component is designed to be a display component rather than a form input component.
If form integration becomes a requirement in the future, features like:
- Form field integration
- Value validation
- Form submission handling
- Form state management
would need to be implemented and documented.Based on the provided examples and implementation, I don't see any environment-specific examples or features that would warrant documentation about server vs. client rendering, platform-specific behavior, environmental dependencies, or special rendering cases.
The examples provided (`base`, `multiple`, `overlay`, and `overlay-custom-color`) demonstrate basic usage patterns, styling variations, and component composition, but don't showcase any environment-specific functionality.
The QR Code component appears to work consistently across environments without any special considerations needed for server-side rendering (SSR) or client-side rendering (CSR).
Therefore, following the strict rules provided, I'll skip this section as no environment-specific features exist in the current implementation.

---

# QR Code
Generate scannable codes to share links and information instantly.
<Showcase name="base" />
## Features
<Features api={api} />
## Anatomy
<AnatomyTable api={api} />
## Examples
### Basic Usage
The QR code component provides a simple way to generate scannable codes. The basic setup requires a `value` prop for the encoded content and an optional `level` prop for error correction.
<Showcase name="base" />
The `value` prop accepts any string to be encoded, while `level` determines error correction strength ("L", "M", "Q", "H"). The example uses `level="H"` for maximum error correction.
### Visual Features
#### Custom Colors and Overlay
You can customize the QR code's appearance with custom colors and add an overlay image in the center.
<Showcase name="overlay-custom-color" />
The example demonstrates:
- Custom fill color using the `fill` prop on `QRCode.PatternPath`
- Background styling through CSS classes on `QRCode.Frame`
- Center overlay image using `QRCode.Overlay`
### Advanced Usage
#### Multiple QR Codes
You can render multiple QR codes on the same page, each with unique values and styling.
<Showcase name="multiple" />
This example shows:
- Independent QR codes with different values
- One basic QR code and one with an overlay
- Proper spacing and layout for multiple instances## Component State
### Using Component State
The QR code component's state can be controlled through two main props on the `QRCode.Root` component:
1. `value` - Sets the text content to be encoded in the QR code
2. `level` - Controls the error correction level ("L", "M", "Q", "H")
Here's how to use these props:
<Showcase name="base" />
In this example, we set:
- `value` prop to "https://qwikui.com" to encode a URL
- `level` prop to "H" for high error correction
### Multiple QR Codes
You can render multiple QR codes with different values on the same page:
<Showcase name="multiple" />
This example demonstrates:
- Creating two QR codes with the same value but different presentations
- One basic QR code and one with an overlay
- Both using high ("H") error correction level
### Custom Styling
The QR code's appearance can be customized through props:
<Showcase name="overlay-custom-color" />
This example shows:
- Setting custom fill color using the `fill` prop on `QRCode.PatternPath`
- Adding custom frame styling through CSS classes
- Including an overlay image while maintaining QR code functionality
The component maintains its functionality regardless of styling changes, ensuring the QR code remains scannable while allowing for visual customization.
Note: The component automatically updates the QR code pattern whenever the `value` or `level` props change, ensuring the displayed code always matches the current props.Based on the provided implementation and examples, I'll document the QR code component's configuration options.
## Core Configuration
### QR Code Value and Error Correction
The QR code can be configured through two essential props on the `QRCode.Root` component:
- `value`: The text or URL to encode (string)
- `level`: Error correction level ("L" | "M" | "Q" | "H")
As shown in the `base` example above, these props determine the QR code's content and reliability:
> The default error correction level is "L" (Low). Higher levels provide better error correction but increase code density.
### Dimensions
The QR code's size is controlled through the `width` and `height` props on the `QRCode.PatternSvg` component. As demonstrated in all examples above, the standard size is 200x200 pixels.
> The SVG viewBox is automatically calculated based on the QR code's data matrix size, ensuring proper scaling regardless of dimensions.
## Advanced Configuration
### Pattern Customization
The QR code pattern can be customized through the `fill` attribute on `QRCode.PatternPath`. As shown in the `overlay-custom-color` example above, you can specify any valid color value.
### Overlay System
The `QRCode.Overlay` component provides a layering system for placing content on top of the QR code. As demonstrated in the `overlay` example above, this is commonly used for logos or branding elements.
Technical considerations for overlays:
```typescript
// Recommended overlay image size constraints
const maxOverlaySize = qrCodeSize * 0.3; // 30% of QR code size
const minOverlaySize = qrCodeSize * 0.1; // 10% of QR code size
```
> When using overlays, ensure the error correction level is set to "H" to maintain readability despite the covered pattern areas.
### Multiple Instances
The component supports multiple QR codes on the same page, as shown in the `multiple` example above. Each instance maintains its own isolated context and state.
Technical constraints:
- Each QR code requires unique DOM IDs if specified
- Memory usage scales linearly with the number of instances
- Pattern calculation is performed independently for each instanceBased on the provided component implementation and examples, I don't see any form-specific features or examples for the QR Code component. The component is primarily focused on displaying and customizing QR codes rather than form integration.
The available examples (`base`, `multiple`, `overlay-custom-color`, and `overlay`) demonstrate visual customization and display features, but none show form integration, validation, or submission functionality.
Since there are no form-specific features to document, this section can be skipped. The QR Code component is designed to be a display component rather than a form input component.
If form integration becomes necessary in future versions, features like:
- Form field integration
- Value validation
- Form submission handling
- Form state management
would need to be implemented and documented accordingly.Based on the provided examples and implementation, I don't see any environment-specific examples or features that would warrant documentation about server vs. client rendering, platform-specific behavior, environmental dependencies, or special rendering cases.
The examples provided (`base`, `multiple`, `overlay`, and `overlay-custom-color`) demonstrate basic usage patterns, styling variations, and component composition, but don't showcase any environment-specific functionality.
The QR Code component appears to work consistently across environments without any special considerations needed for server-side rendering (SSR) or client-side rendering (CSR).
Therefore, following the strict rules provided, I'll skip this section as no environment-specific features exist in the current implementation.

---

# QR Code
Generate scannable codes to share links and information instantly.
<Showcase name="base" />
## Features
<Features api={api} />
## Anatomy
<AnatomyTable api={api} />
## Examples
### Basic Usage
The QR code component provides a simple way to generate scannable codes. The `value` prop specifies the content to encode, while the `level` prop determines error correction strength.
<Showcase name="base" />
Key features demonstrated:
- `value` prop sets the QR code content
- `level="H"` provides high error correction
- `QRCode.PatternSvg` with specified dimensions (200x200)
- `QRCode.PatternPath` with black fill color
### Visual Features
#### Custom Colors and Overlay
You can customize the QR code appearance with different colors and add an overlay image in the center.
<Showcase name="overlay-custom-color" />
Key features demonstrated:
- Custom blue fill color for `QRCode.PatternPath`
- Custom background color through CSS
- Centered logo overlay using `QRCode.Overlay`
- Custom `aria-label` for accessibility
### Advanced Usage
#### Multiple QR Codes
Multiple QR codes can be rendered on the same page, each with unique values and styling.
<Showcase name="multiple" />
Key features demonstrated:
- Independent QR codes with different content
- Flexible layout with CSS
- One code with overlay, one without
- Consistent sizing across instances## Component State
### Using Component State
The QR code component's state can be controlled through two main props on the `QRCode.Root` component:
1. `value` - Sets the text content to be encoded in the QR code
2. `level` - Controls the error correction level ("L", "M", "Q", "H")
Here's how to use these state-related props:
```typescript
<QRCode.Root 
  value="https://qwikui.com"  // The text to encode
  level="H"                   // High error correction
>
  {/* ... */}
</QRCode.Root>
```
The base example demonstrates the basic usage of these state props:
<Showcase name="base" />
In this example, we're using:
- `value` prop to specify the URL to encode
- `level` prop set to "H" for high error correction
### Multiple QR Codes
You can render multiple QR codes with different states on the same page:
<Showcase name="multiple" />
This example shows how each QR code maintains its own independent state, allowing you to:
- Generate different QR codes with unique values
- Set different error correction levels per instance
- Apply different styling to each instance
### Custom Styling State
The QR code's visual state can be customized through standard CSS and props:
<Showcase name="overlay-custom-color" />
This example demonstrates:
- Setting custom colors for the QR code pattern using the `fill` prop on `QRCode.PatternPath`
- Applying custom background colors through CSS classes
- Adding an overlay while maintaining QR code functionality
The component will automatically update its visual representation whenever the `value` or `level` props change, ensuring the QR code always reflects the current state.
Note: The component handles all state updates internally - you only need to provide the desired values through props. There's no need to manually manage or sync state.Based on the provided implementation and examples, I'll document the QR code component's configuration options.
## Core Configuration
### QR Code Value and Error Correction
The QR code can be configured through two essential props on the `QRCode.Root` component:
- `value`: The text or URL to encode (string)
- `level`: Error correction level ("L" | "M" | "Q" | "H")
As shown in the `base` example above, these props control the core functionality of the QR code generation.
> The default error correction level is "L" (Low) if not specified.
### Dimensions
The QR code size is controlled through the `width` and `height` props on the `QRCode.PatternSvg` component. As demonstrated in all examples above, the standard size is 200x200 pixels.
> The SVG viewBox is automatically calculated based on the QR code matrix size, ensuring proper scaling regardless of dimensions.
## Advanced Configuration
### Pattern Customization
The QR code pattern can be customized through the `fill` attribute on `QRCode.PatternPath`. As shown in the `overlay-custom-color` example above, you can specify any valid color value.
### Overlay Configuration
The `QRCode.Overlay` component supports any content, typically used with images. The overlay is automatically centered and positioned above the QR code pattern. As demonstrated in the `overlay` example above, this is commonly used to add logos or branding elements.
Technical considerations for overlays:
```typescript
// Recommended overlay image dimensions
const maxOverlaySize = qrCodeSize * 0.3; // 30% of QR code size
const minOverlaySize = qrCodeSize * 0.1; // 10% of QR code size
```
> To maintain QR code readability, overlay images should not exceed 30% of the QR code's total area.
### Frame Container
The `QRCode.Frame` component serves as a wrapper for styling and positioning. While it accepts all standard div props, it's recommended to use CSS classes for styling to maintain consistency across different states and variations.Based on the provided component implementation and examples, I don't see any form-specific features or examples for the QR Code component. The component is primarily focused on displaying and customizing QR codes rather than form integration.
The available examples (`base`, `multiple`, `overlay-custom-color`, and `overlay`) demonstrate visual customization and display features, but none show form integration, validation, or submission functionality.
Since there are no form-specific features to document, this section can be skipped. The QR Code component is designed to be a display component rather than a form input component.
If form integration becomes a feature in the future, this section should be updated to document those capabilities.Based on the provided examples and implementation, I don't see any environment-specific examples or features that would warrant documentation about server vs. client rendering, platform-specific behavior, environmental dependencies, or special rendering cases.
The examples provided (`base`, `multiple`, `overlay`, and `overlay-custom-color`) demonstrate basic usage patterns, styling variations, and component composition, but don't showcase any environment-specific functionality.
The QR Code component appears to work consistently across environments without any special considerations needed for server-side rendering (SSR) or client-side rendering (CSR).
Therefore, following the strict rules provided, I'll skip this section as no environment-specific features exist in the current implementation.

---

# QR Code
Generate scannable codes to share links and information instantly.
<Showcase name="base" />
## Features
<Features api={api} />
## Anatomy
<AnatomyTable api={api} />
## Examples
### Basic Usage
The QR code component provides a simple way to generate scannable codes. The basic setup requires a `value` prop for the encoded content and an optional `level` prop for error correction.
<Showcase name="base" />
The `value` prop accepts any string to be encoded, while the `level` prop can be set to `"L"`, `"M"`, `"Q"`, or `"H"` for different error correction levels.
### Visual Features
#### Custom Colors and Overlay
You can customize the QR code's appearance with custom colors and add an overlay image in the center.
<Showcase name="overlay-custom-color" />
The `fill` prop on `QRCode.PatternPath` controls the QR code color, while `QRCode.Overlay` allows placing an image or content on top of the code.
### Advanced Usage
#### Multiple QR Codes
Multiple QR codes can be rendered on the same page, each with unique values and styling.
<Showcase name="multiple" />
Each QR code maintains its own context and can have different values, styles, and overlays while coexisting on the same page.## Component State
### Using Component State
The QR code component's state can be controlled through two main props on the `QRCode.Root` component:
1. `value` - Sets the text content to be encoded in the QR code
2. `level` - Controls the error correction level ("L", "M", "Q", "H")
Here's how to use these state-related props:
<Showcase name="base" />
In this example, we set:
- `value` prop to "https://qwikui.com" to encode a URL
- `level` prop to "H" for high error correction
### Multiple QR Codes
You can render multiple QR codes with different states on the same page:
<Showcase name="multiple" />
This example demonstrates:
- Independent state management for each QR code instance
- Different values can be encoded simultaneously
- Each QR code maintains its own error correction level
### Custom Styling State
The QR code's visual state can be customized through styling props:
<Showcase name="overlay-custom-color" />
This example shows:
- Setting custom fill color through the `fill` prop on `QRCode.PatternPath`
- Custom frame styling through CSS classes
- Adding an overlay while maintaining QR code functionality
The component maintains its functionality regardless of styling changes, ensuring the QR code remains scannable even with custom colors and overlays.
Note: When customizing colors, ensure sufficient contrast between the pattern and background for reliable scanning.Based on the provided implementation and examples, I'll document the QR code component's configuration options.
## Core Configuration
### QR Code Value and Error Correction
The QR code content and error correction level can be configured through the `QRCode.Root` component's props:
```typescript
type QRCodeProps = {
  value?: string;
  level?: "L" | "M" | "Q" | "H";
}
```
- `value`: The text or URL to encode in the QR code
- `level`: Error correction level
  - `L`: Low (7% recovery)
  - `M`: Medium (15% recovery)
  - `Q`: Quartile (25% recovery)
  - `H`: High (30% recovery)
As shown in the `base` example above, the default configuration uses level `"H"` for maximum error correction, which is recommended when using overlays.
### Dimensions
The QR code size is controlled through the `width` and `height` props on the `QRCode.PatternSvg` component. As shown in all examples above, a common size is 200x200 pixels, but this can be adjusted based on your needs.
> The QR code maintains its readability at different sizes due to the SVG-based rendering.
## Advanced Configuration
### Pattern Customization
The QR code pattern can be customized through the `QRCode.PatternPath` component. As shown in the `overlay-custom-color` example above, you can modify the `fill` attribute to change the QR code color.
### Multiple Instances
As demonstrated in the `multiple` example above, you can render multiple QR codes on the same page with different configurations. Each instance maintains its own state and context, allowing for independent:
- Values
- Error correction levels
- Styling
- Overlays
> When using multiple instances, ensure each QR code has a unique value to prevent confusion during scanning.
### Zero Border Output
The QR code is generated with zero border padding by default. This allows for precise control over spacing through the container elements rather than the QR code itself.
```typescript
const qrResult = encode(value, {
  ecc: level,
  border: 0
});
```
This configuration cannot be modified as it's integral to the component's layout system.Based on the provided component implementation and examples, I don't see any form-specific features or examples for the QR Code component. The component is primarily focused on displaying and customizing QR codes rather than form integration.
The available examples (`base`, `multiple`, `overlay-custom-color`, and `overlay`) demonstrate visual customization and display features, but none show form integration, validation, or submission functionality.
Since there are no form-specific features to document, this section can be skipped. The QR Code component is designed to be a display component rather than a form input component.
If form integration becomes a requirement in the future, features like:
- Form field integration
- Value validation
- Form submission handling
- Form state management
would need to be implemented and documented.Based on the provided examples and implementation, I don't see any environment-specific examples or features that would warrant documentation about server vs. client rendering, platform-specific behavior, or environmental dependencies.
The examples provided (`base`, `multiple`, `overlay`, and `overlay-custom-color`) all demonstrate standard usage patterns, styling variations, and component composition rather than environment-specific concerns.
The QR code component appears to work consistently across environments without any special considerations needed for server-side rendering (SSR) or client-side rendering (CSR).
Since there are no environment-specific examples or features to document, this section should be omitted to maintain clear and focused documentation.

---

# QR Code
Generate scannable codes to share links and information instantly.
<Showcase name="base" />
## Features
<Features api={api} />
## Anatomy
<AnatomyTable api={api} />
## Examples
### Basic Usage
The QR code component provides a simple way to generate scannable codes. The `value` prop specifies the content to encode, while the `level` prop determines error correction strength.
<Showcase name="base" />
Key features demonstrated:
- `value` prop to set the QR code content
- `level="H"` for high error correction
- Basic structure with `Root`, `Frame`, `PatternSvg`, and `PatternPath` components
### Visual Features
#### Custom Colors and Overlay
You can customize the QR code appearance with custom colors and add an overlay image in the center.
<Showcase name="overlay-custom-color" />
Key features demonstrated:
- Custom fill color using the `fill` prop on `PatternPath`
- Background styling through CSS classes
- Center overlay with the `Overlay` component
- Custom `aria-label` for accessibility
### Advanced Usage
#### Multiple QR Codes
Display multiple QR codes side by side, each with unique content and styling.
<Showcase name="multiple" />
Key features demonstrated:
- Independent QR codes with different values
- Consistent styling across instances
- Optional overlay support per instance
- Flexible layout arrangement## Component State
### Using Component State
The QR code component's state is primarily controlled through two main props on the `QRCode.Root` component:
1. `value` - Sets the text content to be encoded in the QR code
2. `level` - Controls the error correction level ("L", "M", "Q", "H")
As shown in the base example above, you can set these props directly:
```typescript
<QRCode.Root 
  value="https://qwikui.com" 
  level="H"
>
  {/* ... */}
</QRCode.Root>
```
The QR code will automatically update whenever these props change. This allows you to dynamically update the QR code content in response to user interactions or other state changes in your application.
### State Interactions
The QR code component is primarily a display component, so it doesn't expose any direct event handlers. However, you can wrap it in your own event handling logic to update its state:
```typescript
<button onClick$={() => updateQRValue("new value")}>
  Update QR Code
</button>
<QRCode.Root value={qrValue}>
  {/* ... */}
</QRCode.Root>
```
As shown in the multiple example above, you can have multiple QR codes on the same page, each with its own independent state. This is useful when you need to display different QR codes that update independently.
The error correction level can be adjusted based on your needs:
- "L" (Low) - 7% of data can be restored
- "M" (Medium) - 15% of data can be restored
- "Q" (Quartile) - 25% of data can be restored
- "H" (High) - 30% of data can be restored
Higher error correction levels make the QR code more resistant to damage or poor scanning conditions, but also make the pattern more complex.Based on the provided implementation and examples, I'll document the QR code component's configuration options.
## Core Configuration
### Basic Setup
The QR code component requires two essential configurations: `value` and `level` props on the `QRCode.Root` component.
As shown in the `base` example above, the minimal configuration includes:
- `value`: The text or URL to encode
- `level`: Error correction level ("L", "M", "Q", "H")
> The default error correction level is "L" (Low) if not specified.
### Dimensions
The QR code size is controlled through the `width` and `height` attributes on the `QRCode.PatternSvg` component. As shown in all examples above, the recommended size is 200x200 pixels for optimal scanning.
> The QR code maintains its aspect ratio regardless of the container size.
## Advanced Configuration
### Error Correction Levels
The `level` prop supports four values with different data redundancy:
```typescript
type ErrorCorrectionLevel = "L" | "M" | "Q" | "H"
```
- L (Low): 7% of data can be restored
- M (Medium): 15% of data can be restored
- Q (Quartile): 25% of data can be restored
- H (High): 30% of data can be restored
As shown in the `overlay` and `overlay-custom-color` examples above, using level "H" is recommended when adding an overlay to ensure reliable scanning.
### Pattern Customization
The QR code pattern is rendered using SVG paths, allowing for color customization through the `fill` attribute on `QRCode.PatternPath`. As demonstrated in the `overlay-custom-color` example above, you can modify the pattern color to match your design requirements.
> The QR code maintains functionality regardless of color choice, but ensure sufficient contrast for reliable scanning.
### Technical Constraints
1. Border: The component generates QR codes with zero border padding
2. Size: The minimum recommended size is 200x200 pixels for reliable scanning
3. Overlay: When using overlays, the QR code must maintain sufficient pattern visibility
4. SVG Rendering: The pattern uses path-based rendering for optimal scaling
These technical specifications ensure the QR code remains functional while providing flexibility for customization.Based on the provided component implementation and examples, I don't see any form-specific features or examples for the QR Code component. The component is primarily focused on displaying and customizing QR codes rather than form integration.
The available examples (`base`, `multiple`, `overlay-custom-color`, and `overlay`) demonstrate visual customization and display features, but none show form integration, validation, or submission functionality.
Since there are no form-specific features to document, this section can be skipped. The QR Code component is designed to be a display component rather than a form input component.
If form integration becomes a requirement in the future, features like:
- Form field integration
- Value validation
- Form submission handling
- Form state management
would need to be implemented and documented.Based on the provided examples and implementation, I don't see any environment-specific examples or features that would warrant documentation about server vs. client rendering, platform-specific behavior, environmental dependencies, or special rendering cases.
The examples provided (`base`, `multiple`, `overlay`, and `overlay-custom-color`) demonstrate basic usage patterns, styling variations, and component composition, but don't showcase any environment-specific functionality.
The QR Code component appears to work consistently across environments without any special considerations needed for server-side rendering (SSR) or client-side rendering (CSR).
Therefore, following the strict rules provided, I'll skip this section as no environment-specific features exist in the current implementation.

---

# File Upload
A drag and drop interface for uploading files with support for filtering and multiple selections.
<Showcase name="hero" />
## Features
<Features api={api} />
## Anatomy
<AnatomyTable api={api} />
## Examples
### Basic Usage
The most basic implementation allows users to upload files through drag and drop or button click.
### Visual Features
The file upload can be styled to match your application's design system.
### Advanced Usage
#### Multiple File Upload
Enable multiple file selection and handle batch uploads.
#### Disabled State
Control the interactive state of the upload component.## Component State
### Using Component State
The File Upload component's state can be controlled through several props on the `FileUpload.Root` component:
1. **Multiple File Selection**
- Control whether multiple files can be selected using the `multiple` prop
- When `multiple` is `true`, users can select or drop multiple files at once
- When `false` (default), only one file can be selected at a time
2. **File Type Filtering**
- Restrict allowed file types using the `accept` prop
- Accepts standard MIME types or file extensions
- As shown in the Image Upload example above, use `accept="image/*"` to allow only image files
3. **Disabled State**
- Disable all file upload interactions using the `disabled` prop
- When disabled, the component prevents:
  - File selection via the trigger button
  - Drag and drop operations
  - File input interactions
### State Interactions
The component provides a callback to handle file changes:
1. **File Change Handler**
```typescript
<FileUpload.Root
  onFilesChange$={(files) => {
    // files is an array of FileInfo objects
    files.forEach(file => {
      console.log(file.name, file.size, file.type);
    });
  }}
>
```
The `onFilesChange$` prop receives an array of `FileInfo` objects containing:
- `name`: File name
- `size`: File size in bytes
- `type`: MIME type
- `lastModified`: Last modification timestamp
- `file`: The actual File object (if available)
2. **Drag State**
The component automatically manages drag states:
- Visual feedback when files are dragged over the dropzone
- Drag state is cleared when:
  - Files are dropped
  - Cursor leaves the dropzone
  - Component is disabled
3. **Processing State**
- Files are processed immediately after selection or drop
- The component handles both single and multiple file selections based on the `multiple` prop
- Invalid file types are automatically rejected when using the `accept` prop
The state management is designed to be simple and declarative, allowing you to focus on handling the files rather than managing the upload interface state.Based on the provided examples and API documentation, I'll document the configuration options for the File Upload component.
## Core Configuration
### File Selection Mode
The File Upload component supports both single and multiple file selection modes through the `multiple` prop on `FileUpload.Root`.
As shown in the hero example above, by default, the component operates in single file mode. To enable multiple file selection, add the `multiple` prop to `FileUpload.Root`.
> The `multiple` prop is `false` by default, allowing only single file selection.
### File Type Filtering
The component supports file type filtering through the `accept` prop on `FileUpload.Root`. This allows you to restrict which file types users can select.
As shown in the hero example above, you can use MIME types or file extensions to filter files:
> Common accept values:
> - `"image/*"` - All image types
> - `".pdf,.doc,.docx"` - Specific file extensions
> - `"video/*,audio/*"` - Multiple MIME types
### Disabled State
The File Upload component can be disabled entirely using the `disabled` prop on `FileUpload.Root`. When disabled:
- The trigger button becomes unclickable
- The file input is disabled
- Drag and drop functionality is prevented
- Visual feedback indicates the disabled state
## Advanced Configuration
### File Change Handling
The component provides detailed file information through the `onFilesChange$` callback prop on `FileUpload.Root`. The callback receives an array of `FileInfo` objects with the following structure:
```typescript
interface FileInfo {
  name: string;
  size: number;
  type: string;
  lastModified: number;
  file: NoSerialize<File>;
}
```
> The `file` property is wrapped in `NoSerialize` to prevent serialization issues in Qwik's resumability model.
### Drag and Drop Configuration
The component automatically handles drag and drop events and provides visual feedback through data attributes:
```typescript
interface DropzoneAttributes {
  "data-dragging": string | undefined;  // Present when files are being dragged
  "data-disabled": string | undefined;  // Present when dropzone is disabled
}
```
These attributes can be used for styling and state management in more complex implementations.Looking through the provided examples and implementation, I don't see any specific form-related examples or features that would warrant a Forms section in the documentation.
The FileUpload component is primarily focused on handling file selection and drag-and-drop functionality, rather than form integration. While files could be used as part of a larger form submission, the component itself doesn't have specific form features like:
- Form field integration
- Built-in validation
- Form state management
- Form submission handling
The examples show file handling and callbacks that could be used to implement form functionality, but these would be application-specific implementations rather than built-in form features of the component.
If form integration is needed, developers would need to:
1. Wrap the FileUpload component in their own form component
2. Handle the `onFilesChange$` callback to manage form state
3. Implement their own validation and submission logic
Since there are no specific form-related examples or built-in form features, I'll skip writing this section to avoid providing incomplete or misleading documentation.Looking through the provided examples and implementation, I don't see any specific environment-related examples or features that would warrant dedicated environment documentation.
The FileUpload component works consistently across server and client environments without any special considerations needed. The core functionality of drag-and-drop, file selection, and file processing remains the same regardless of rendering context.
While the component does handle browser-specific file APIs (like File, FileReader, and DataTransfer), these are standard web APIs that work the same way in both server-side and client-side rendered contexts.
Since there are no environment-specific examples or features to document, I'll leave this section empty rather than create artificial distinctions or repeat basic usage patterns.

---

# Pagination
Navigate through large sets of data with numbered pages and controls.
<Showcase name="hero" />
## Features
<Features api={api} />
## Anatomy 
<AnatomyTable api={api} />
## Examples
### Basic Usage
The most basic pagination setup requires `totalPages` and `pages` props to define the range of pages available.
<Showcase name="basic" />
The `totalPages` prop determines the total number of pages, while the `pages` array provides the actual page numbers to display. The `currentPage` prop sets which page is initially active.
### Visual Features
#### Disabled State
Pages can be disabled to prevent interaction when at boundaries or based on conditions.
<Showcase name="disabled" />
The `isDisabled` prop on `Pagination.Page` disables individual pages, while the `disabled` prop on `Pagination.Root` disables the entire pagination component.
#### Ellipsis Display
Customize how page gaps are displayed using ellipsis.
<Showcase name="ellipsis" />
The `ellipsis` prop on `Pagination.Root` allows customization of the gap indicator between page numbers.
#### First and Last Navigation
Add quick navigation to the start and end of the pagination range.
<Showcase name="first-last" />
The `isFirst` and `isLast` props on `Pagination.Previous` and `Pagination.Next` respectively enable first/last page navigation.
### Advanced Usage
#### Keyboard Navigation
Enable full keyboard control for accessibility.
<Showcase name="keyboard" />
Arrow keys navigate between pages, while Home/End keys jump to first/last pages. The component handles focus management automatically.
#### Custom Page Length
Control how many pages are displayed at once.
<Showcase name="length" />
The `totalPages` prop determines the overall number of pages, while `siblingCount` controls how many adjacent pages are shown.
#### Sibling Count
Adjust how many pages appear on either side of the current page.
<Showcase name="siblings" />
The `siblingCount` prop determines how many page numbers are visible before and after the current page.## Component State
### Using Component State
The Pagination component offers several ways to control its state through props and events:
1. **Current Page Control**
As shown in the `page` example above, you can set the initial page using the `currentPage` prop on `Pagination.Root`. For reactive control, use the `bind:page` prop which accepts a signal.
2. **Total Pages**
The `totalPages` prop determines the total number of pages available for navigation, as demonstrated in the `length` example above.
3. **Disabled State**
As shown in the `disabled` example above, the entire pagination can be disabled by setting the `disabled` prop on `Pagination.Root`. This will prevent all user interactions with the component.
### State Interactions
1. **Page Change Events**
The component provides an `onPageChange$` prop to handle page navigation events:
```typescript
<Pagination.Root
  totalPages={10}
  onPageChange$={(page: number) => {
    // Handle page change
    console.log(`Navigated to page ${page}`);
  }}
>
  {/* ... */}
</Pagination.Root>
```
2. **Navigation Controls**
As demonstrated in the `first-last` example above, you can control navigation behavior using the `isFirst` and `isLast` props on the `Previous` and `Next` components respectively.
3. **Sibling Pages**
The `siblingCount` prop controls how many page numbers are shown on either side of the current page, as shown in the `siblings` example above. This helps manage the pagination's visual state when dealing with large numbers of pages.
4. **Custom Ellipsis**
As shown in the `ellipsis` example above, you can customize the appearance of truncated pages using the `ellipsis` prop on `Pagination.Root`.
The pagination state is automatically managed to ensure:
- Previous/Next buttons are disabled at boundaries
- Current page is highlighted
- Correct page range is displayed based on current selection
- Proper ellipsis placement for large page countsBased on the provided implementation and examples, I'll document the configuration options for the Pagination component.
## Core Configuration
### Page Management
The Pagination component requires essential configuration for managing page counts and navigation:
- `totalPages`: Required number that sets the total available pages
- `currentPage`: Optional initial page number (defaults to 1)
- `pages`: Required array of page numbers to display
As shown in the `basic` example above, these props work together to create the foundation of the pagination:
> The `currentPage` will automatically be constrained between 1 and `totalPages`
### Sibling Pages
The component supports configurable sibling pages through the `siblingCount` prop:
- Controls how many page numbers appear on each side of the current page
- Defaults to 1 if not specified
- Must be a non-negative number
As shown in the `siblings` example above, increasing `siblingCount` displays more adjacent page numbers.
### Ellipsis Display
The ellipsis configuration determines how page gaps are displayed:
- `ellipsis`: Optional custom element to replace the default "..." display
- Automatically appears when there are too many pages to display
- Intelligently positioned based on current page location
As shown in the `ellipsis` example above, you can customize the ellipsis display.
## Advanced Configuration
### Controlled State
The component supports controlled state management through:
- `bind:page`: Signal to control the current page externally
- `onPageChange$`: Event handler called when page changes
As shown in the `page` example above, these props enable external state control.
### Navigation Controls
Additional navigation options can be configured:
- `isFirst`: Boolean prop on `<Pagination.Previous />` to jump to first page
- `isLast`: Boolean prop on `<Pagination.Next />` to jump to last page
As shown in the `first-last` example above, these enable quick navigation to boundaries.
### Disabled State
The pagination supports complete disabling:
- `disabled`: Boolean prop to disable all pagination interactions
- Automatically disables boundary navigation when at first/last page
As shown in the `disabled` example above, this controls the interactive state of the entire component.
> When disabled, all interactive elements receive the `disabled` attribute and appropriate ARIA statesLooking through the provided examples and implementation, I don't see any specific form-related examples or functionality for the Pagination component. The Pagination component appears to be focused on navigation and page selection rather than form integration.
The component doesn't include:
- Form field integration
- Form validation features
- Form submission handling
- Form state management
- Hidden input elements for form submission
Therefore, there is no form-specific configuration section needed for this component's documentation.
The component's primary purpose is to provide pagination controls for navigating through pages of content, rather than collecting form data. If form integration is needed, it would need to be implemented separately from this component.Looking through the provided examples and implementation, I don't see any environment-specific examples or features that would warrant documentation about server vs client rendering, platform-specific behavior, environmental dependencies, or special rendering cases.
The examples provided (`basic`, `disabled`, `ellipsis`, `first-last`, `hero`, `keyboard`, `length`, `navigation`, `page`, `per-page`, `siblings`) all demonstrate standard usage patterns, state management, and configuration options rather than environment-specific concerns.
Since there are no environment-specific examples or features to document, I'll leave this section empty to avoid creating unnecessary documentation about basic usage patterns or repeating information that belongs in other sections.

---

# One-Time Password Input
Securely collect and validate numeric codes with automatic field navigation and keyboard support.
<Showcase name="hero" />
## Features
<Features api={api} />
## Anatomy
<AnatomyTable api={api} />
## Examples
### Basic Usage
The OTP input can be initialized with a default value using the `value` prop.
<Showcase name="initial" />
This example demonstrates:
- Using `value` prop to set an initial uncontrolled value
- Default numeric validation pattern
- Automatic field navigation
### Visual Features
The OTP input can be disabled to prevent user interaction.
<Showcase name="disabled" />
This example shows:
- Using the `disabled` prop to control input state
- Visual feedback for disabled state via `data-disabled` attribute
### Advanced Usage
#### Controlled Input
The OTP input can be controlled using signals with `bind:value`.
<Showcase name="reactive" />
This example demonstrates:
- Two-way binding with `bind:value` prop
- Programmatic value updates
- Reactive state management
#### Event Handling
The OTP input supports completion and change events.
<Showcase name="complete" />
This example shows:
- Using `onComplete$` to handle filled state
- Using `onChange$` for value updates
- Automatic validation and field progression
#### Change Events
Monitor input changes with the `onChange$` handler.
<Showcase name="change" />
This example demonstrates:
- Real-time value change detection
- Event handling for input modifications
- Integration with external state## Component State
### Using Component State
The OTP component provides several ways to control its state through props:
1. Initial Value
As shown in the `initial` example above, you can set an initial uncontrolled value using the `value` prop on `<Otp.Root />`:
```tsx
<Otp.Root value="1234">
  {/* OTP items */}
</Otp.Root>
```
2. Controlled Value
For controlled state management, use the `bind:value` prop as demonstrated in the `reactive` example above. This allows you to programmatically update the OTP value.
3. Disabled State 
The `disabled` example shows how to disable the entire OTP input using the `disabled` prop:
```tsx
<Otp.Root disabled={true}>
  {/* OTP items */}
</Otp.Root>
```
### State Interactions
1. Change Events
As shown in the `change` example, use the `onChange$` prop to listen for value changes:
```tsx
<Otp.Root 
  onChange$={(value) => {
    // Handle value change
  }}
>
  {/* OTP items */}
</Otp.Root>
```
2. Completion Events
The `complete` example demonstrates using `onComplete$` to handle when all OTP digits are filled:
```tsx
<Otp.Root
  onComplete$={() => {
    // Handle OTP completion
  }}
>
  {/* OTP items */}
</Otp.Root>
```
3. Password Manager Integration
Control password manager suggestion positioning with the `shiftPWManagers` prop (enabled by default):
```tsx
<Otp.Root shiftPWManagers={false}>
  {/* OTP items */}
</Otp.Root>
```
The component maintains internal state for:
- Current input value
- Focus state
- Selection range
- Current input position
- Validation state
These states are automatically managed based on user interaction and the provided props.Based on the provided examples and API documentation, I'll document the configuration options for the OTP component.
## Core Configuration
### Input Pattern
By default, the OTP component only accepts numeric input (0-9). You can customize the input validation pattern through the `pattern` prop on `<Otp.HiddenInput />`. The default pattern is `^[0-9]*$`.
### Initial Value
The OTP component supports setting an initial uncontrolled value. As shown in the `initial` example above, you can pass the `value` prop to `<Otp.Root />` to set the initial value.
### Password Manager Integration
The OTP component includes built-in support for password managers. By default, password manager suggestions are shifted to the right of the OTP input. This behavior can be controlled via the `shiftPWManagers` prop on `<Otp.Root />`:
```typescript
<Otp.Root shiftPWManagers={false}>
  {/* ... */}
</Otp.Root>
```
### Input Length
The number of OTP digits is determined by the number of `<Otp.Item />` components rendered. The component automatically manages the maximum input length based on this count.
## Advanced Configuration
### Value Binding
For reactive control over the OTP value, the component supports value binding through the `bind:value` prop. As shown in the `reactive` example above, this allows two-way binding with a signal.
### Completion Handling
The component provides completion detection through the `onComplete$` prop. As demonstrated in the `complete` example above, this handler is called when all OTP digits are filled.
### Change Detection
For granular control over value changes, use the `onChange$` prop. As shown in the `change` example above, this handler is called on every value change, receiving the current OTP value as an argument.
### Disabled State
The entire OTP input can be disabled through the `disabled` prop on `<Otp.Root />`. As shown in the `disabled` example above, this affects all child components and prevents user interaction.
> Note: The disabled state is reflected through the `data-disabled` attribute on both root and individual items, allowing for consistent styling across states.Looking through the provided examples and API documentation, I don't see any specific form-related examples or features for the OTP component. While the component does have an input element, the examples focus on:
- Basic usage and styling (`hero` example)
- State management (`initial`, `reactive`, `disabled` examples)
- Event handling (`change`, `complete` examples)
There are no examples demonstrating:
- Form integration
- Form validation
- Form submission
- Form state handling
Therefore, I'll skip writing the Forms section since it would not provide any meaningful documentation about form-specific features. The OTP component appears to be focused on handling one-time password input functionality rather than form integration specifically.
If form features are added in the future, this section should be updated to document those capabilities.Based on the provided examples and API documentation, I don't see any environment-specific examples (like CSR vs SSR, platform-specific behavior, or environmental dependencies) for the OTP component.
The examples provided (`hero`, `complete`, `disabled`, `initial`, `reactive`, `change`) all demonstrate state management, configuration, and basic usage patterns rather than environment-specific features.
Therefore, I will not create any environment-specific documentation sections as it would not be appropriate for this component's current implementation.

---

# Radio Group
Select a single option from a list of choices with keyboard navigation and accessibility support.
<Showcase name="hero" />
## Features
<Features api={api} />
## Anatomy
<AnatomyTable api={api} />
## Examples
### Basic Usage
The most basic radio group implementation requires a `RadioGroup.Root` component containing `RadioGroup.Item` components with their associated values.
<Showcase name="controlledValue" />
This example demonstrates:
- Using `value` prop on `RadioGroup.Root` to set the selected option
- `RadioGroup.Label` for group identification
- `RadioGroup.Trigger` and `RadioGroup.Indicator` for selection interaction
- Individual `RadioGroup.Item` components with unique values
### Error Handling
Radio groups can display error messages when validation fails, such as when no option is selected.
<Showcase name="error" />
This example shows:
- `RadioGroup.ErrorMessage` component for displaying validation feedback
- Error state automatically managed through the `isErrorSig` context
- Error message visibility controlled by `data-visible` attribute
- ARIA attributes automatically updated for accessibility
The error message appears when no option is selected and disappears when a selection is made, providing clear feedback to users.
Note: The examples available demonstrate core functionality like controlled values and error handling. Additional examples for visual features and advanced usage would typically be included but are not available in the provided example set.## Component State
### Using Component State
The Radio Group component provides several ways to manage its state through props on the `RadioGroup.Root` component.
1. **Controlled Value**
As shown in the `controlledValue` example above, you can control the selected value using the `value` prop:
```typescript
const value = useSignal<string>("Item 2");
<RadioGroup.Root value={value.value}>
  // Radio items
</RadioGroup.Root>
```
2. **Uncontrolled Value**
You can set an initial uncontrolled value using the `defaultValue` prop:
```typescript
<RadioGroup.Root defaultValue="Item 1">
  // Radio items
</RadioGroup.Root>
```
3. **Required State**
Make the radio group required by setting the `required` prop:
```typescript
<RadioGroup.Root required>
  // Radio items
</RadioGroup.Root>
```
4. **Disabled State**
Disable the entire radio group using the `disabled` prop:
```typescript
<RadioGroup.Root disabled>
  // Radio items
</RadioGroup.Root>
```
### State Interactions
1. **Handling Selection Changes**
Listen for selection changes using the `onChange$` prop:
```typescript
<RadioGroup.Root 
  onChange$={(value) => {
    // Handle the new selected value
    console.log('Selected:', value);
  }}
>
  // Radio items
</RadioGroup.Root>
```
2. **Error State**
As shown in the `error` example above, the Radio Group automatically manages error states when validation fails. The error state is cleared when a valid selection is made.
3. **Description State**
Enable description support by setting the `isDescription` prop:
```typescript
<RadioGroup.Root isDescription>
  <RadioGroup.Description>
    Additional context about the radio group
  </RadioGroup.Description>
  // Radio items
</RadioGroup.Root>
```
The state management in Radio Group is designed to handle common use cases while maintaining accessibility and providing clear feedback to users through visual indicators and ARIA attributes.Based on the provided implementation and examples, I'll document the core configuration options for the Radio Group component.
## Core Configuration
### Value Management
The Radio Group can be configured in both controlled and uncontrolled modes. The value can be managed through the `value` prop on `RadioGroup.Root`.
As shown in the `controlledValue` example above, you can control the selected value by passing a value prop:
> The `value` prop accepts a string and determines which radio option is currently selected.
### Required Validation
The Radio Group supports required field validation through the `required` prop on `RadioGroup.Root`. When enabled, it enforces selection before form submission.
As shown in the `error` example above, the component displays an error message when no option is selected and the field is required.
### Description Support
The Radio Group can be configured to display additional descriptive text through the `isDescription` prop on `RadioGroup.Root`. 
> When `isDescription` is true but no description is provided, a warning will be logged to the console.
### Disabled State
The entire Radio Group can be disabled using the `disabled` prop on `RadioGroup.Root`. When disabled:
```typescript
type DisabledConfig = {
  disabled?: boolean; // Disables all radio options when true
}
```
### Event Handling
The Radio Group supports change event handling through the `onChange$` prop:
```typescript
type ChangeHandler = {
  onChange$?: QRL<(checked: string) => void>;
}
```
This handler is called whenever a radio option is selected, receiving the new value as an argument.
### Hidden Input Configuration
For form submission, the component includes a hidden native radio input that can be configured with:
```typescript
type HiddenInputConfig = {
  name?: string;      // Form field name
  required?: boolean; // Required field validation
  value?: string;     // Current value
}
```
These configurations ensure proper form integration while maintaining accessibility and native form behavior.## Forms
The Radio Group component includes form integration features through the `RadioGroup.HiddenNativeInput` component and built-in validation support.
### Form Validation
The Radio Group provides built-in validation with error handling through the `RadioGroup.ErrorMessage` component.
<Showcase name="error" />
In this example, the following form-specific features are demonstrated:
- `RadioGroup.ErrorMessage` displays validation feedback when no option is selected
- The error message is automatically shown/hidden based on selection state
- The `data-visible` attribute on `RadioGroup.ErrorMessage` controls visibility
- Form validation state is managed internally by the component
### Form Integration 
The component includes a hidden native radio input through `RadioGroup.HiddenNativeInput` that enables form submission and browser-native validation.
Key form integration features:
- The `required` prop can be passed to `RadioGroup.Root` to make selection mandatory
- The `name` prop on `RadioGroup.Root` sets the form field name
- The `value` prop determines the submitted form value
- Native form validation is supported through the hidden input
The error example above demonstrates these form capabilities working together to provide a complete form field solution.
Note: The `controlledValue` example shows controlled form state management but since it was covered in the state management section, it is not repeated here.Based on the provided examples and implementation, I don't see any environment-specific examples (like CSR vs SSR) or environment-specific features that need to be documented separately.
The examples provided (`controlledValue`, `error`, and `hero`) demonstrate basic usage patterns, state management, and error handling - but don't showcase any environment-specific behaviors or rendering cases.
Since there are no environment-specific examples or features to document, this section should be skipped to avoid redundancy and maintain focus on the core component functionality that has been covered in other sections.

---

# Checkbox
A clickable input that lets users make binary choices or select multiple options.
<Showcase name="hero" />
## Features
<Features api={api} />
## Anatomy
<AnatomyTable api={api} />
## Examples
### Basic Usage
The most basic checkbox implementation requires a `Checkbox.Root` component with a `Checkbox.Trigger` and `Checkbox.Indicator` nested inside.
<Showcase name="initial" />
The `checked` prop on `Checkbox.Root` sets the initial checked state. When checked, the `Checkbox.Indicator` becomes visible.
### Visual Features
#### Labels and Descriptions
Add descriptive text with `Checkbox.Label` and `Checkbox.Description` components. The `isDescription` prop on `Checkbox.Root` enables description support.
<Showcase name="description" />
#### Mixed State
Checkboxes support an indeterminate state using the `"mixed"` value. This is useful for parent/child checkbox relationships.
<Showcase name="mixed-initial" />
### Advanced Usage
#### Form Integration
For form submissions, add `Checkbox.HiddenInput` to create a native checkbox input. Use `name` and `value` props to control form data.
<Showcase name="form" />
The `required` prop enforces validation:
<Showcase name="validation" />
You can customize the submitted value using the `value` prop:
<Showcase name="value" />
#### Error Handling
Display error messages using the `Checkbox.ErrorMessage` component. This automatically sets the appropriate ARIA attributes.
<Showcase name="validation" />
#### Mixed State Management
For complex selection scenarios, use the `bind:checked` prop to handle mixed states programmatically.
<Showcase name="mixed-reactive" />
The checkbox cycles through mixed → checked → unchecked states when clicked.## Component State
### Using Component State
The checkbox component provides several ways to control its state:
1. **Initial State**
As shown in the Initial example, you can set the initial checked state using the `checked` prop on `Checkbox.Root`:
```tsx
<Checkbox.Root checked>
  <Checkbox.Trigger>
    <Checkbox.Indicator />
  </Checkbox.Trigger>
</Checkbox.Root>
```
2. **Controlled State**
For controlled state management, use the `bind:checked` prop as demonstrated in the Reactive example. This allows you to bind the checkbox state to your application's state.
3. **Indeterminate State**
The checkbox supports a third "mixed" or indeterminate state, as shown in the Mixed Initial example. This is useful for representing partially selected states, like in a tree structure or bulk selection interface.
### State Interactions
1. **Change Events**
As shown in the Change example, use the `onChange$` prop to handle state changes:
```tsx
<Checkbox.Root 
  onChange$={(checked) => {
    // Handle the new checked state
  }}
>
```
2. **Disabled State**
The Disabled example demonstrates how to disable the checkbox using the `disabled` prop. When disabled:
- The checkbox cannot be interacted with
- The visual state reflects the disabled status
- All interactions are prevented
3. **Programmatic Control**
As shown in the Programmatic example, you can programmatically control the checkbox state from outside the component:
```tsx
<button onClick$={() => {
  // Update the bound checked state
  isChecked.value = true;
}}>
  Check the checkbox
</button>
```
4. **Mixed State Transitions**
When in a mixed state, clicking the checkbox will first transition to a checked state, then follow the normal checked/unchecked cycle on subsequent clicks, as demonstrated in the Mixed Reactive example.
The checkbox maintains a predictable state transition flow:
- mixed → checked
- checked → unchecked
- unchecked → checkedBased on the examples and API documentation provided, I'll document the configuration options for the Checkbox component.
## Core Configuration
### Initial State
The checkbox can be configured with an initial state using the `checked` prop on `Checkbox.Root`. As shown in the `initial` example above, this sets an uncontrolled initial value.
> The default value is `false` if not specified.
### Value Configuration
The checkbox supports three states:
- `false` (unchecked)
- `true` (checked) 
- `"mixed"` (indeterminate)
As shown in the `mixed-initial` example above, the indeterminate state can be set initially.
### Form Integration
The checkbox can be configured for form submission with these props:
- `name` - Form field name
- `value` - Custom value for form submission (defaults to "on")
- `required` - Makes the field required
As shown in the `value` example above, you can customize the submitted value.
## Advanced Configuration
### State Management
The checkbox supports both controlled and uncontrolled state management:
```typescript
// Uncontrolled
<Checkbox.Root checked={true} />
// Controlled
<Checkbox.Root bind:checked={isCheckedSignal} />
```
### Description Configuration
When using `Checkbox.Description`, you must set `isDescription` prop on `Checkbox.Root`:
```typescript
<Checkbox.Root isDescription>
  <Checkbox.Description>...</Checkbox.Description>
</Checkbox.Root>
```
> Failing to set `isDescription` will trigger a console warning.
### Technical Constraints
1. The `bind:checked` signal must be of type `Signal<boolean | "mixed">`
2. The `onChange$` handler receives the new state as its only argument
3. When in `mixed` state, the first click will set the state to `true`
These behaviors can be observed in the `mixed-reactive` example above.## Forms
The Checkbox component provides form integration through the `<Checkbox.HiddenInput>` component, which renders a native checkbox input that's visually hidden but still accessible for form submission.
<Showcase name="form" />
The following props can be used to configure the form behavior:
- `name`: Sets the name of the form field
- `value`: Sets a custom value for the checkbox (defaults to "on")
- `required`: Makes the checkbox a required form field
<Showcase name="value" />
## Form Validation
The Checkbox supports form validation through the `<Checkbox.ErrorMessage>` component. When rendered, it automatically puts the checkbox in an invalid state and connects it with the error message via ARIA.
<Showcase name="validation" />
The error message is displayed when form validation fails, and the checkbox trigger receives the appropriate ARIA attributes:
- `aria-invalid="true"`
- `aria-describedby` pointing to the error message
## Mixed State in Forms
For complex form scenarios, the checkbox supports a mixed (indeterminate) state that can be used when a form field represents a partial selection.
<Showcase name="form-mixed" />
The mixed state is reflected in the hidden input's `indeterminate` property, ensuring proper form submission behavior.I've reviewed all the examples and component implementations, and I don't find any environment-specific examples or features that would warrant documentation in this section. The examples provided (`hero`, `initial`, `reactive`, `programmatic`, `disabled`, `label`, `description`, `form`, `form-mixed`, `validation`, `value`, `mixed-initial`, `mixed-reactive`, `change`) all demonstrate state management, accessibility, form integration, and configuration patterns rather than environment-specific behaviors.
The Checkbox component appears to work consistently across server and client environments without any special considerations or limitations. There are no examples demonstrating environment-specific features such as:
- Server vs client rendering differences
- Platform-specific behaviors
- Environmental dependencies
- Special rendering cases
Therefore, this section should be skipped as per the strict rules provided.

---


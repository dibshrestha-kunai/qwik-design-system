# Checkbox

A customizable input that lets users select one or more options from a list.

<Showcase name="hero" />

## Features

<Features api={api} />

## Anatomy

<AnatomyTable api={api} />

## Accessibility

### Labeling

Labels are essential for screen readers to identify the checkbox's purpose.

<Showcase name="label" />

In this example, we use the `Checkbox.Label` component to provide an accessible label. The label is automatically associated with the checkbox through ARIA attributes.

### Description

Add descriptive text to provide additional context about the checkbox's purpose.

<Showcase name="description" />

This example demonstrates using `Checkbox.Description` with the `isDescription` prop on `Checkbox.Root` to provide additional context. The description is automatically associated with the checkbox through ARIA attributes.

### Error Messages

Display validation errors in an accessible way.

<Showcase name="validation" />

This example shows how to use `Checkbox.ErrorMessage` to display validation errors. The error message is automatically associated with the checkbox through ARIA attributes and updates the checkbox's `aria-invalid` state.# Checkbox

Select or deselect options with a simple click, perfect for forms and lists.

<Showcase name="hero" />

## Features

<Features api={api} />

## Anatomy

<AnatomyTable api={api} />

## Accessibility

### Labeling

Labels are essential for screen readers to identify the checkbox's purpose. Use the `Checkbox.Label` component to provide an accessible label.

<Showcase name="label" />

In this example, we use the `Checkbox.Label` component which automatically associates the label with the checkbox trigger through proper ARIA attributes.

### Description

For complex choices, provide additional context using the `Checkbox.Description` component. This text is automatically linked to the checkbox through ARIA attributes.

<Showcase name="description" />

The `isDescription` prop on `Checkbox.Root` must be set to `true` when using `Checkbox.Description`.

### Error Messages

When validation fails, use `Checkbox.ErrorMessage` to provide clear feedback. This component automatically sets the appropriate ARIA attributes for accessibility.

<Showcase name="validation" />

The error message is automatically associated with the checkbox through `aria-describedby` and sets `aria-invalid` to true.

### Form Integration

For proper form submission, include `Checkbox.HiddenInput`. This ensures the checkbox works with native form handling while maintaining accessibility.

<Showcase name="form" />

The `name` and `required` props on `Checkbox.Root` are automatically passed to the hidden input element.## Component State

### Initial State

You can set the initial checked state of the checkbox using the `checked` prop on the `Checkbox.Root` component.

<Showcase name="initial" />

### Reactive State

To bind the checkbox state to a reactive signal, use the `bind:checked` prop on the `Checkbox.Root` component. This enables two-way data binding between the checkbox and your application state.

<Showcase name="reactive" />

### Handling State Changes

The `onChange$` prop allows you to listen for changes in the checkbox state. The handler receives the new checked state as an argument.

<Showcase name="change" />

### Programmatic Control

You can programmatically control the checkbox state by modifying the signal passed to the `bind:checked` prop.

<Showcase name="programmatic" />

### Disabled State

To disable the checkbox, set the `disabled` prop to `true` on the `Checkbox.Root` component. This prevents user interaction and applies appropriate visual styling.

<Showcase name="disabled" />

### Indeterminate State

The checkbox supports an indeterminate (mixed) state, which can be useful for representing partially selected states in hierarchical selections. Set the value of `bind:checked` to `"mixed"` to enable this state.

<Showcase name="mixed-initial" />

You can also programmatically toggle between regular and indeterminate states:

<Showcase name="mixed-reactive" />

The indeterminate state automatically transitions to checked state when clicked, following the standard checkbox behavior pattern.## Component State

### Initial State

You can set the initial checked state of the checkbox using the `checked` prop on the `Checkbox.Root` component.

<Showcase name="initial" />

### Reactive State

To bind the checkbox state to a reactive signal, use the `bind:checked` prop on the `Checkbox.Root` component. This enables two-way data binding between the checkbox and your application state.

<Showcase name="reactive" />

### Handling State Changes

The `onChange$` prop allows you to listen for changes in the checkbox state. The handler receives the new checked state as an argument.

<Showcase name="change" />

### Programmatic Control

You can programmatically control the checkbox state by modifying the signal passed to the `bind:checked` prop.

<Showcase name="programmatic" />

### Disabled State

To disable the checkbox, set the `disabled` prop to `true` on the `Checkbox.Root` component. This prevents user interaction and applies appropriate visual styling.

<Showcase name="disabled" />

### Indeterminate State

The checkbox supports an indeterminate (mixed) state, which can be useful for representing partially selected states in hierarchical selections. Set the value of `bind:checked` to `"mixed"` to enable this state.

<Showcase name="mixed-initial" />

You can also programmatically toggle between regular and indeterminate states:

<Showcase name="mixed-reactive" />

The indeterminate state automatically transitions to checked state when clicked, following the standard checkbox behavior pattern.Based on the provided examples and API documentation, I don't see any specific configuration examples for the Checkbox component. The examples provided are focused on:

- Basic usage
- State management (initial, reactive, disabled)
- Form integration
- Validation
- Accessibility features (labels, descriptions, error messages)
- Mixed/indeterminate states

There are no examples demonstrating configuration options like:
- Custom filtering
- Menu behavior
- Animation configuration
- Custom positioning
- Custom timing
- Custom sorting
- etc.

The Checkbox component appears to be focused on core functionality rather than configurable behaviors. If you'd like to document configuration options, you would need to add examples demonstrating specific configurable features of the component.

Would you like me to help document a different aspect of the component, or would you like suggestions for potential configuration options that could be added to the component?Based on the provided examples and API documentation, I don't see any specific configuration examples for the Checkbox component. The examples provided are focused on:

- Basic usage
- State management (initial, reactive, disabled)
- Form integration
- Validation
- Accessibility features (labels, descriptions, error messages)
- Mixed/indeterminate states

There are no examples demonstrating configuration options like:
- Custom filtering
- Menu behavior
- Animation configuration
- Custom positioning
- Custom timing
- Custom sorting
- etc.

The Checkbox component appears to be focused on core checkbox functionality without additional configuration options that would warrant a dedicated configuration section in the documentation.

If you'd like to document configuration options, you would need examples that demonstrate specific configurable behaviors beyond the basic checkbox functionality shown in the current examples.I'll help document the behavioral aspects of the Checkbox component based on the provided examples. Let me analyze the examples that demonstrate behavioral patterns.

## Behavioral Patterns

### Mixed State

The Checkbox supports a mixed (indeterminate) state, which is useful for representing partially selected states, commonly used in parent-child checkbox relationships.

<Showcase name="mixed-reactive" />

In this example, we use:
- The `bind:checked` prop with a signal that can accept `boolean | "mixed"` type
- The `Checkbox.Indicator` component conditionally renders different icons based on the state

When in a mixed state:
1. Clicking the checkbox will set it to `checked`
2. Subsequent clicks will toggle between `checked` and `unchecked`

You can programmatically set the mixed state:

<Showcase name="mixed-initial" />

### Programmatic Control

The checkbox state can be controlled programmatically using the `bind:checked` signal:

<Showcase name="programmatic" />

This example demonstrates:
- External control of the checkbox state
- Using the `bind:checked` prop for two-way data binding
- Programmatic updates that automatically reflect in the UI

### Change Detection

You can monitor checkbox state changes using the `onChange$` prop:

<Showcase name="change" />

The `onChange$` handler:
- Receives the new checkbox state as an argument
- Is called after the internal state updates
- Can be used to trigger side effects or update other parts of your application

Note: The `onChange$` handler is not called during the initial render, only on user interactions or programmatic changes.

These behavioral patterns provide flexibility in handling complex checkbox interactions and state management scenarios in your application.I'll help document the behavioral aspects of the Checkbox component based on the provided examples. Let me analyze the examples that demonstrate behavioral patterns.

## Behavioral Patterns

### Mixed State

The Checkbox supports a mixed (indeterminate) state, which is useful for representing partially selected states, often used in parent-child checkbox relationships.

<Showcase name="mixed-reactive" />

In this example, we use:
- The `bind:checked` prop with a signal that can accept `boolean | "mixed"` type
- The `Checkbox.Indicator` component conditionally renders different icons based on the state

When in a mixed state:
- Clicking the checkbox will set it to `checked`
- Subsequent clicks will toggle between `checked` and `unchecked`
- The mixed state can only be set programmatically

### Programmatic Control

You can programmatically control the checkbox state from outside the component.

<Showcase name="programmatic" />

This example demonstrates:
- Using the `bind:checked` prop for two-way data binding
- External button triggering state changes
- The checkbox immediately reflects state changes from external controls

### Click Behavior

The checkbox can be toggled by clicking either the trigger or its associated label.

<Showcase name="label" />

Key behaviors:
- Clicking the `Checkbox.Trigger` toggles the state
- Clicking the `Checkbox.Label` also toggles the state
- The checkbox maintains a single source of truth for both interaction points

These are the main behavioral patterns demonstrated in the examples. The component follows standard checkbox interaction patterns while providing additional features like the mixed state and programmatic control.

Note: I've focused solely on behavioral aspects and excluded other topics like accessibility, state management, and form integration as requested.Based on the provided examples and component implementation, I'll document the form-related configuration for the Checkbox component.

## Forms

The checkbox can be used within forms by utilizing the `<Checkbox.HiddenInput>` component, which creates a hidden native checkbox input for form submission.

<Showcase name="form" />

The following props can be used to configure the form behavior on the `<Checkbox.Root>` component:

- `name`: Sets the name attribute for the form field
- `required`: Makes the checkbox a required form field
- `value`: Sets a custom value to be submitted (defaults to "on")

<Showcase name="value" />

When a custom `value` is provided, the form will submit that value instead of the default "on" value when the checkbox is checked.

## Validation

The checkbox supports form validation through the `<Checkbox.ErrorMessage>` component.

<Showcase name="validation" />

When the `<Checkbox.ErrorMessage>` component is rendered, the checkbox trigger receives an `aria-invalid` state and is automatically associated with the error message through `aria-describedby`.

This allows you to integrate the checkbox with any form validation library or create custom validation logic.

The error state can be triggered by:
- Form submission attempts
- Real-time validation
- External validation libraries

The error message is only displayed when rendered, making it easy to conditionally show validation feedback based on your application's needs.Based on the provided examples and component implementation, I'll document the form-related configuration for the Checkbox component.

## Forms

The checkbox can be used within forms by utilizing the `<Checkbox.HiddenInput>` component, which creates a hidden native checkbox input for form submission.

<Showcase name="form" />

The following props can be used to configure the form behavior on the `<Checkbox.Root>` component:

- `name`: Sets the name attribute for the form field
- `required`: Makes the checkbox a required form field
- `value`: Sets a custom value to be submitted (defaults to "on")

<Showcase name="value" />

When a custom `value` is provided, the form will submit that value instead of the default "on" value when the checkbox is checked.

## Validation

The checkbox supports form validation through the `<Checkbox.ErrorMessage>` component.

<Showcase name="validation" />

When the `<Checkbox.ErrorMessage>` component is rendered, the checkbox trigger receives an `aria-invalid` state and is automatically associated with the error message through `aria-describedby`.

This allows you to integrate the checkbox with any form validation library or create custom validation logic.

The error state can be triggered by:
- Form submission attempts
- Real-time validation
- External validation libraries

The error message is only displayed when rendered, making it easy to conditionally show validation feedback based on your application's needs.Based on the provided examples and component implementation, I don't see any specific environmental examples (such as CSR, SSR, or environment-specific implementations) in the showcase examples.

All the provided examples demonstrate functional aspects like state management, form handling, accessibility, and styling, but none specifically showcase environment-related implementations.

Therefore, I have no environment-specific documentation to write for this component.

---

# Checkbox

A customizable input that lets users select one or more options from a list.

<Showcase name="hero" />

## Features

<Features api={api} />

## Anatomy

<AnatomyTable api={api} />

## Accessibility

### Labeling

Labels are essential for screen readers to identify the checkbox's purpose.

<Showcase name="label" />

In this example, we use the `Checkbox.Label` component to provide an accessible label. The label is automatically associated with the checkbox through ARIA attributes.

### Description

Add descriptive text to provide additional context about the checkbox's purpose.

<Showcase name="description" />

This example demonstrates using `Checkbox.Description` with the `isDescription` prop on `Checkbox.Root` to provide additional context. The description is automatically associated with the checkbox through ARIA attributes.

### Error Messages

Display validation errors in an accessible way.

<Showcase name="validation" />

This example shows how to use `Checkbox.ErrorMessage` to display validation errors. The error message is automatically associated with the checkbox through ARIA attributes and updates the checkbox's `aria-invalid` state.## Component State

### Initial State

You can set the initial checked state of the checkbox using the `checked` prop on the `Checkbox.Root` component.

<Showcase name="initial" />

### Reactive State

To bind the checkbox state to a reactive signal, use the `bind:checked` prop on the `Checkbox.Root` component. This enables two-way data binding between the checkbox and your application state.

<Showcase name="reactive" />

### Handling State Changes

The `onChange$` prop allows you to listen for changes in the checkbox state. The handler receives the new checked state as an argument.

<Showcase name="change" />

### Programmatic Control

You can programmatically control the checkbox state by modifying the signal passed to the `bind:checked` prop.

<Showcase name="programmatic" />

### Disabled State

To disable the checkbox, set the `disabled` prop to `true` on the `Checkbox.Root` component. This prevents user interaction and applies appropriate visual styling.

<Showcase name="disabled" />

### Indeterminate State

The checkbox supports an indeterminate (mixed) state, which can be set by passing `"mixed"` as the value to either the `checked` prop or through the bound signal.

<Showcase name="mixed-initial" />

You can also control the indeterminate state programmatically:

<Showcase name="mixed-reactive" />

The indeterminate state is automatically cleared when the user interacts with the checkbox, setting it to either checked or unchecked.Based on the provided examples and API documentation, I don't see any specific configuration examples for the Checkbox component. The examples provided are focused on:

- Basic usage
- State management (initial, reactive, disabled)
- Form integration
- Validation
- Accessibility features (labels, descriptions, error messages)
- Mixed/indeterminate states

There are no examples demonstrating configuration options like:
- Custom filtering
- Menu behavior
- Animation configuration
- Custom positioning
- Custom timing
- Custom sorting
- etc.

The Checkbox component appears to be focused on core functionality rather than configurable behaviors. If you want to document configuration options, you would need examples that demonstrate customizable aspects of the component's behavior beyond its basic functionality.

Would you like me to help document a different aspect of the component, or would you like to add some configuration examples to the component first?Looking through the examples, I can identify behavioral patterns related to the checkbox's indeterminate (mixed) state functionality. Let me document this behavior:

### Indeterminate State

The checkbox supports an indeterminate (mixed) state, which is useful for representing partially selected states, commonly used in hierarchical selections like file trees or bulk actions.

When a checkbox is in an indeterminate state:
- The checkbox displays a different visual indicator (typically a minus sign)
- Clicking the checkbox will set it to `checked` state
- Subsequent clicks will toggle between `checked` and `unchecked` states

<Showcase name="mixed-initial" />

The indeterminate state can be programmatically controlled using the `bind:checked` prop with a value of `"mixed"`:

<Showcase name="mixed-reactive" />

Key Differences in Mixed State:
- Visual Representation: Uses a distinct visual indicator to represent the partial selection
- Click Behavior: First click transitions from mixed to checked, then follows normal toggle pattern
- State Flow: mixed → checked → unchecked → checked (and so on)

This behavior is particularly useful for:
- Parent checkboxes that control a group of child checkboxes
- Representing partial selections in bulk actions
- Indicating incomplete or partial states in complex forms

Note: The indeterminate state is a visual state only - the underlying input element will still submit either a checked or unchecked value when used in forms.Based on the provided examples and component implementation, I'll document the form-related configuration for the Checkbox component.

## Forms

The checkbox can be used within forms by utilizing the `<Checkbox.HiddenInput>` component, which creates a hidden native checkbox input for form submission.

<Showcase name="form" />

The following props can be used to configure the form behavior on the `<Checkbox.Root>` component:

- `name`: Sets the name attribute for the form field
- `required`: Makes the checkbox a required form field
- `value`: Sets a custom value to be submitted (defaults to "on")

<Showcase name="value" />

When a custom `value` is provided, the form will submit that value instead of the default "on" value when the checkbox is checked.

## Validation

The checkbox supports form validation through the `<Checkbox.ErrorMessage>` component.

<Showcase name="validation" />

When the `<Checkbox.ErrorMessage>` component is rendered, the checkbox trigger receives an `aria-invalid` state and is automatically associated with the error message through `aria-describedby`.

This allows you to integrate the checkbox with any form validation library or create custom validation logic.

The error state can be used to:
- Display validation messages
- Style the checkbox differently when invalid
- Provide feedback to assistive technologiesBased on the provided examples and component implementation, I don't see any specific environmental examples (such as CSR, SSR, or environment-specific implementations) in the showcase examples.

All the provided examples demonstrate functional aspects like state management, form handling, accessibility, and styling, but none specifically showcase environment-related implementations.

Therefore, I have no environment-specific documentation to write for this component.

---

# Checkbox

Select or deselect options with a simple click, supporting both binary and indeterminate states.

<Showcase name="hero" />

## Features

<Features api={api} />

## Anatomy

<AnatomyTable api={api} />

## Accessibility

### Labeling

Labels are essential for screen readers to identify the checkbox's purpose.

<Showcase name="label" />

In this example, we use the `Checkbox.Label` component to provide an accessible label. The label is automatically associated with the checkbox through ARIA attributes.

### Description

Add detailed explanatory text to help users understand the implications of their choice.

<Showcase name="description" />

This example demonstrates using the `Checkbox.Description` component to provide additional context. The description is automatically linked to the checkbox through ARIA attributes and is read by screen readers.

### Validation

Show error messages when validation fails to guide users toward correct input.

<Showcase name="validation" />

The `Checkbox.ErrorMessage` component provides accessible error feedback. When present, it's automatically announced by screen readers and visually indicates the error state through the `aria-invalid` attribute.## Component State

### Initial State

You can set the initial checked state of a checkbox using the `checked` prop on the `Checkbox.Root` component.

<Showcase name="initial" />

### Reactive State

To bind the checkbox state to a reactive signal, use the `bind:checked` prop on the `Checkbox.Root` component.

<Showcase name="reactive" />

The checkbox state can be read from the bound signal.

### Programmatic Control

The checkbox state can be controlled programmatically using the bound signal.

<Showcase name="programmatic" />

### Change Events

Listen for state changes using the `onChange$` prop. The handler receives the new checked state as an argument.

<Showcase name="change" />

### Disabled State

To disable the checkbox, set the `disabled` prop on the `Checkbox.Root` component. This prevents user interaction and applies appropriate styling.

<Showcase name="disabled" />

The disabled state can also be controlled programmatically.

### Indeterminate State

The checkbox supports an indeterminate (mixed) state, which is useful for representing partially selected states, like in a tree structure.

<Showcase name="mixed-initial" />

The indeterminate state can be set:
- Initially using `checked="mixed"`
- Reactively using a signal with `bind:checked`

<Showcase name="mixed-reactive" />

When clicked, an indeterminate checkbox transitions to the checked state, then follows the normal checked/unchecked cycle.Based on the provided examples and API documentation, I don't see any specific configuration examples for the Checkbox component. The examples provided are focused on:

- Basic usage
- State management (initial, reactive, disabled)
- Form integration
- Validation
- Accessibility features (labels, descriptions, error messages)
- Mixed/indeterminate states

There are no examples demonstrating configuration options like:
- Custom filtering
- Menu behavior
- Animation configuration
- Custom positioning
- Custom timing
- Custom sorting
- etc.

The Checkbox component appears to be focused on core checkbox functionality without additional configuration options that would warrant a dedicated configuration section in the documentation.

If you'd like to document configuration options, you would need examples that demonstrate specific configurable behaviors beyond the basic checkbox functionality shown in the current examples.Based on the provided examples and component implementation, I'll document the form-related configuration for the Checkbox component.

## Forms

The checkbox can be used within forms by utilizing the `<Checkbox.HiddenInput>` component, which creates a hidden native checkbox input for form submission.

<Showcase name="form" />

The following props can be used to configure the form behavior on the `<Checkbox.Root>` component:

- `name`: Sets the name attribute for the form field
- `required`: Makes the checkbox a required form field
- `value`: Sets a custom value to be submitted (defaults to "on")

<Showcase name="value" />

When a custom `value` is provided, the form will submit that value instead of the default "on" value when the checkbox is checked.

## Validation

The checkbox supports form validation through the `<Checkbox.ErrorMessage>` component.

<Showcase name="validation" />

When the `<Checkbox.ErrorMessage>` component is rendered, the checkbox trigger receives an `aria-invalid` state and is automatically associated with the error message through `aria-describedby`.

This allows you to integrate the checkbox with any form validation library or create custom validation logic.

The error state can be triggered by:
- Form submission attempts
- Real-time validation
- External validation libraries

The error message is only displayed when rendered, making it easy to conditionally show validation feedback based on your application's needs.Based on the provided examples and component implementation, I don't see any specific environmental examples (such as CSR, SSR, or environment-specific implementations) in the showcase examples.

All the provided examples demonstrate functionality like state management, form handling, accessibility features, and various checkbox states, but none specifically showcase environment-related implementations.

Therefore, I have no environment-specific documentation to write for this component.

---

# File Upload

A drag and drop interface for uploading files with support for filtering and multiple selections.

<Showcase name="hero" />

## Features

<Features api={api} />

## Anatomy

<AnatomyTable api={api} />

## Examples



This example demonstrates core functionality using:
- `FileUpload.Root` as the main container
- `FileUpload.Input` for handling file selection
- `FileUpload.Dropzone` for drag and drop functionality
- `FileUpload.Trigger` for opening the system file dialog
- `onFilesChange$` prop to handle uploaded files



This example shows:
- Custom styling applied to the dropzone and trigger
- Visual feedback during drag operations using `data-dragging` attribute
- File type filtering with `accept="image/*"` prop to only allow image files

### Advanced Usage


This implementation showcases:
- `multiple` prop to allow selecting multiple files
- Batch file processing through `onFilesChange$`
- Custom handling for each uploaded file
- FormData preparation for potential server uploads


This example demonstrates:
- `disabled` prop to prevent file uploads
- Visual feedback for disabled state using `data-disabled` attribute
- Blocked drag and drop interactions
- Disabled trigger button## Component State

### Internal State Structure

The File Upload component maintains several key state values through Qwik's context system:

```typescript
// Core state values
interface FileUploadContext {
  inputRef: Signal<HTMLInputElement | undefined>;  // Reference to hidden file input
  isDragging: Signal<boolean>;                     // Current drag state
  files: Signal<FileInfo[]>;                       // Selected/dropped files
  multiple: boolean;                               // Multiple file selection mode
  accept?: string;                                 // Allowed file types
  disabled?: boolean;                              // Disabled state
  onFilesChange$?: PropFunction<(files: FileInfo[]) => void>; // Change callback
}
```

The state is initialized in the `FileUploadRoot` component:

```typescript
const inputRef = useSignal<HTMLInputElement>();
const isDragging = useSignal(false);
const files = useSignal<FileInfo[]>([]);

const context = {
  inputRef,
  isDragging,
  files,
  multiple: props.multiple ?? false,
  accept: props.accept,
  disabled: props.disabled,
  onFilesChange$: props.onFilesChange$
};
```

### State Updates

The component handles state updates in two main scenarios:

1. File Selection via Input:
```typescript
const onChange$ = $((e: Event) => {
  const input = e.target as HTMLInputElement;
  if (!input.files) return;
  
  const newFiles = Array.from(input.files).map(file => ({
    name: file.name,
    size: file.size,
    type: file.type,
    lastModified: file.lastModified,
    file: noSerialize(file)
  }));

  if (context.multiple) {
    context.files.value = [...context.files.value, ...newFiles];
  } else {
    context.files.value = newFiles.slice(0, 1);
  }
  
  context.onFilesChange$?.(context.files.value);
});
```

2. Drag and Drop State:
```typescript
// Drag enter updates
const onDragEnter$ = $((e: DragEvent) => {
  if (context.disabled) return;
  if (!isDragging.value) {
    isDragging.value = true;
    context.isDragging.value = true;
  }
});

// Drag leave updates
const onDragLeave$ = $((e: DragEvent) => {
  if (context.disabled) return;
  isDragging.value = false;
  context.isDragging.value = false;
});
```

The state management ensures:
- Files are properly processed whether selected via input or dropped
- Multiple file selection is handled based on the `multiple` prop
- Drag state provides visual feedback during drag operations
- Disabled state prevents any state updates
- Parent components are notified of file changes through the callback

The state is shared across all child components through Qwik's context system, allowing coordinated updates and consistent UI feedback.Based on the provided examples and API documentation, I'll document the configuration options for the File Upload component.

## Core Configuration

### File Selection Mode

The File Upload component supports both single and multiple file selection modes through the `multiple` prop on `FileUpload.Root`.

As shown in the multiple files example above, enabling multiple file selection allows users to upload several files at once.

> By default, `multiple` is set to `false`, allowing only single file selection.

### File Type Filtering

The component supports file type filtering through the `accept` prop on `FileUpload.Root`. 

As shown in the image-only example above, you can restrict file types using MIME types or file extensions:

```typescript
// Common accept patterns
accept="image/*"           // All image types
accept=".pdf,.doc,.docx"   // Specific file extensions
accept="video/*,audio/*"   // Multiple MIME types
```

> The `accept` prop is optional. When not specified, all file types are allowed.

### Disabled State

The component can be disabled entirely using the `disabled` prop on `FileUpload.Root`. 

As shown in the disabled example above, when disabled:
- The trigger button becomes non-interactive
- Drag and drop functionality is disabled
- File input becomes disabled

### File Change Notifications

The component provides file change notifications through the `onFilesChange$` prop on `FileUpload.Root`. The callback receives an array of `FileInfo` objects:

```typescript
interface FileInfo {
  name: string;
  size: number;
  type: string;
  lastModified: number;
  file: NoSerialize<File>;
}
```

> The `file` property is non-serializable and should be processed immediately if needed for uploads.

## Technical Constraints

### Browser Support

The component requires modern browser features:
- HTML5 File API
- Drag and Drop API
- DataTransfer API

### File Size Limitations

File size limits are determined by:
- Browser memory constraints
- Input element limitations
- JavaScript heap size

> It's recommended to implement server-side file size validation for production use.

### Performance Considerations

For optimal performance:
- Process files in batches when handling multiple files
- Use `URL.createObjectURL()` for image previews
- Release object URLs when no longer neededLooking through the examples and implementation, I don't see any specific form-related examples or features that would warrant a Forms section in the documentation.

The FileUpload component is primarily focused on handling file selection and upload functionality through drag & drop or file dialog interactions. While files could be part of a larger form, the component itself doesn't have specific form integration features like:

- Form field validation
- Form state integration 
- Form submission handling
- Native form element bindings

The examples show file selection and handling through callbacks (`onFilesChange$`), but don't demonstrate form-specific functionality.

If form integration examples were to be added in the future, they could demonstrate:

- Using the component within a `<form>` element
- Integration with form validation libraries
- Form submission handling with FormData
- Error state handling and validation messages

But since these aren't currently implemented, I'll skip the Forms section to avoid documenting non-existent features.Based on the provided examples and component implementation, I don't see any specific environment-related examples or features that would warrant dedicated environment documentation.

The FileUpload component works consistently across server and client environments without requiring special handling. The core functionality - drag and drop, file selection, and file processing - operates the same way regardless of the rendering environment.

While the component does handle client-side interactions like drag events and file selection, these are fundamental to the component's functionality rather than environment-specific features.

Since there are no examples demonstrating environment-specific behavior or implementation differences between server and client rendering, I'll leave this section empty to avoid creating unnecessary documentation.

---

# QR Code

Generate scannable codes to encode text, URLs, and other data in a visual format.

<Showcase name="base" />

## Features

<Features api={api} />

## Anatomy

<AnatomyTable api={api} />

## Examples

### Basic Usage

The QR code component requires a value to encode and an error correction level. The `value` prop specifies the content to encode, while the `level` prop determines error correction strength.

<Showcase name="base" />

In this example, we use:
- `QRCode.Root` with `value` and `level` props
- `QRCode.Frame` for containing the QR code
- `QRCode.PatternSvg` for setting dimensions
- `QRCode.PatternPath` for rendering the actual QR code pattern

### Visual Features

You can customize the appearance of your QR code with overlays and custom colors.

<Showcase name="overlay-custom-color" />

This example demonstrates:
- Custom fill color using the `fill` prop on `QRCode.PatternPath`
- Custom background styling through CSS classes
- Image overlay using `QRCode.Overlay` component

### Advanced Usage

Multiple QR codes can be rendered on the same page, each with unique values and styling.

<Showcase name="multiple" />

This example shows:
- Multiple QR code instances with different values
- Independent styling and overlay configuration
- Proper spacing and layout management

Each QR code maintains its own context and can be styled independently while preserving proper functionality.## Component State

### Internal State Structure

The QR code component maintains three core state values using Qwik's `useSignal`:

```typescript
const value = useSignal(props.value || "");
const level = useSignal(props.level || "L");
const data = useSignal<boolean[][]>([]);
```

- `value`: Stores the text to be encoded in the QR code
- `level`: Controls the error correction level ("L", "M", "Q", "H")
- `data`: Holds the generated QR code matrix as a 2D boolean array

These values are managed by the `QRCode.Root` component and shared with child components through Qwik's context system:

```typescript
const context = {
  value,
  level,
  data
};
useContextProvider(qrCodeContextId, context);
```

### State Updates

The QR code updates automatically when either the `value` or `level` signals change. This is handled by a `useTask$` that tracks these dependencies:

```typescript
useTask$(({ track }) => {
  track(() => value.value);
  track(() => level.value);
  const qrResult = encode(value.value, {
    ecc: level.value,
    border: 0
  });
  data.value = qrResult.data;
});
```

As shown in the `base` example above, the QR code pattern updates reactively when the value changes. The pattern is rendered through the `QRCodePatternPath` component, which transforms the boolean matrix into SVG path data:

```typescript
const pathData = context.data.value.reduce((acc, row, y) => {
  row.forEach((isBlack, x) => {
    if (isBlack) {
      acc += `M ${x} ${y} h 1 v 1 h -1 z `;
    }
  });
  return acc;
}, "");
```

The `multiple` example demonstrates how each QR code instance maintains its own independent state, allowing multiple QR codes with different values to coexist on the same page.

The state management system ensures that:
- Initial values can be provided through props
- Changes to value or error correction level trigger immediate updates
- The QR code matrix is automatically regenerated when needed
- State is properly isolated between multiple instancesBased on the provided implementation and examples, I'll document the QR code component's configuration options.

## Core Configuration

### QR Code Value and Error Correction

The QR code content and error correction level can be configured through the `QRCode.Root` component's props:

- `value`: The text or URL to encode (string)
- `level`: Error correction level ("L", "M", "Q", "H")

As shown in the `base` example above, you can set these properties to generate a basic QR code with default settings.

```typescript
type ErrorCorrectionLevel = "L" | "M" | "Q" | "H";
// L = Low (7% recovery)
// M = Medium (15% recovery)
// Q = Quartile (25% recovery)
// H = High (30% recovery)
```

> The default error correction level is "L" if not specified.

### Dimensions and Scaling

The QR code's size is controlled through the `width` and `height` props on the `QRCode.PatternSvg` component. As shown in all examples above, the default size is 200x200 pixels.

The QR code pattern automatically scales to fit within these dimensions while maintaining its aspect ratio, thanks to the SVG viewBox calculation.

## Advanced Configuration

### Custom Pattern Rendering

The QR code pattern can be customized using the `fill` attribute on `QRCode.PatternPath`. As shown in the `overlay-custom-color` example above, you can change the pattern color to any valid CSS color value.

### Overlay Configuration

The `QRCode.Overlay` component supports custom content positioning. As demonstrated in the `overlay` example above, it automatically centers the content over the QR code while maintaining code readability.

> Important: When using overlays, it's recommended to use a higher error correction level ("H") to ensure the QR code remains scannable despite the overlay content.

### Technical Constraints

- The QR code is generated with zero borders by default
- The pattern data is dynamically updated when either the `value` or `level` props change
- The SVG pattern uses a path-based rendering approach for optimal performance and scaling
- The component maintains a 1:1 aspect ratio regardless of container dimensionsBased on the provided component implementation, examples, and APIs, I don't see any form-specific features or examples for the QR Code component. The component is primarily focused on displaying and customizing QR codes rather than form integration.

The available examples (`base`, `multiple`, `overlay`, and `overlay-custom-color`) demonstrate visual customization and multiple instance usage, but none show form integration, validation, or submission handling.

Since there are no form-specific features to document, this section can be skipped. The QR Code component is designed to be a display component rather than a form input component.

If form integration becomes necessary in the future, features like:
- Form field integration
- Value validation
- Form submission handling
- Form state management

would need to be implemented and documented.Based on the provided examples and implementation, I don't see any environment-specific examples or features that would warrant documentation about server vs. client rendering, platform-specific behavior, environmental dependencies, or special rendering cases.

The examples provided (`base`, `multiple`, `overlay`, and `overlay-custom-color`) demonstrate basic usage patterns, styling variations, and component composition, but don't showcase any environment-specific functionality.

The QR Code component appears to work consistently across different rendering environments without special considerations, so there's no need for environment-specific documentation in this case.

If environment-specific examples or features are added in the future, this section should be updated accordingly.

---

# Scroll Area

A customizable container that adds scrollbars when content overflows its boundaries.

<Showcase name="both" />

## Features

<Features api={api} />

## Anatomy

<AnatomyTable api={api} />

## Examples

### Basic Usage

The scroll area component can be configured with different scrollbar visibility behaviors using the `type` prop.

<Showcase name="vertical" />

This example demonstrates:
- Using `ScrollArea.Root` with default `type="hover"` visibility
- Vertical scrollbar appears when content overflows
- The `ScrollArea.Viewport` wraps the content
- `ScrollArea.Scrollbar` and `ScrollArea.Thumb` create the custom scrollbar

### Visual Features

#### Horizontal Scrolling

For content that extends beyond the horizontal bounds, add a horizontal scrollbar.

<Showcase name="horizontal" />

This example shows:
- Setting `orientation="horizontal"` on `ScrollArea.Scrollbar`
- Horizontal thumb moves as content scrolls left/right
- Content container width controls when horizontal scrolling activates

#### Both Scrollbars

When content overflows in both directions, both scrollbars can be displayed simultaneously.

<Showcase name="both" />

This example demonstrates:
- Multiple `ScrollArea.Scrollbar` components with different orientations
- Automatic thumb sizing based on content dimensions
- Smooth interaction between vertical and horizontal scrolling

### Advanced Usage


This example shows:
- Setting `type="always"` for persistent scrollbars
- Scrollbars remain visible even when not actively scrolling
- The `hideDelay` prop can be used with `type="scroll"` to control how long scrollbars remain visible after scrolling stops## Component State

The ScrollArea component maintains several internal state values to manage scrollbar visibility, dragging behavior, and overflow detection.

1. Internal State Structure

The core state is managed through the ScrollArea context:

```typescript
interface ScrollAreaContext {
  // Element References
  thumbRef: Signal<HTMLDivElement | undefined>;
  viewportRef: Signal<HTMLDivElement | undefined>;
  verticalScrollbarRef: Signal<HTMLDivElement | undefined>;
  horizontalScrollbarRef: Signal<HTMLDivElement | undefined>;
  rootRef: Signal<HTMLDivElement | undefined>;
  
  // Visibility Control
  type: ScrollbarVisibility;
  hideDelay: number;
  
  // State Flags
  isScrolling: Signal<boolean>;
  isHovering: Signal<boolean>;
  scrollTimeout: Signal<number>;
  hasOverflow: Signal<boolean>;
}
```

2. State Updates

The component handles state updates through several mechanisms:

Scrollbar Visibility:
```typescript
const shouldShow = () => {
  const hasOverflow = context.hasOverflow.value;
  switch (context.type) {
    case "always":
      return hasOverflow;
    case "hover":
      return context.isHovering.value && hasOverflow;
    case "scroll":
      return context.isScrolling.value && hasOverflow;
    case "auto":
      return hasOverflow;
    default:
      return false;
  }
};
```

Drag State Management:
```typescript
const dragData = useSignal({
  startClientY: 0,
  startClientX: 0,
  startScrollTop: 0,
  startScrollLeft: 0,
  activeThumb: null as HTMLElement | null,
  activeScrollbar: null as HTMLElement | null
});
```

Overflow Detection:
```typescript
const updateOverflow = $((viewport: HTMLElement) => {
  const hasVerticalOverflow = viewport.scrollHeight > viewport.clientHeight;
  const hasHorizontalOverflow = viewport.scrollWidth > viewport.clientWidth;
  context.hasOverflow.value = hasVerticalOverflow || hasHorizontalOverflow;
});
```

The state updates are triggered by:
- Mouse events (enter/leave for hover state)
- Scroll events (for scroll visibility)
- Resize events (for overflow detection)
- Zoom level changes (for overflow recalculation)
- Drag operations (for thumb positioning)

The ScrollArea maintains these states independently for both vertical and horizontal scrollbars, allowing for precise control over scrollbar behavior and visibility based on user interaction and content overflow conditions.Based on the provided implementation and examples, I'll document the ScrollArea configuration options:

## Scrollbar Visibility

### Visibility Modes

The ScrollArea component supports four visibility modes controlled by the `type` prop on `ScrollArea.Root`:

- `hover` (default): Shows scrollbars when hovering over the scroll area
- `scroll`: Shows scrollbars during scrolling
- `auto`: Always shows scrollbars when content overflows
- `always`: Always shows scrollbars when content overflows

As shown in the `hover-test` example above, scrollbars appear on hover and hide when the mouse leaves.

### Hide Delay

For the `scroll` visibility mode, you can customize how long scrollbars remain visible after scrolling stops using the `hideDelay` prop:

```typescript
type PublicRootProps = {
  hideDelay?: number; // milliseconds
}
```

The default delay is 600ms. As shown in the `custom-delay-test` example above, you can extend this delay for better visibility.

## Scrollbar Configuration

### Orientation

ScrollArea supports both vertical and horizontal scrollbars through the `orientation` prop on `ScrollArea.Scrollbar`:

```typescript
type PublicScrollBarType = {
  orientation?: "vertical" | "horizontal";
}
```

As shown in the `both` example above, you can use both orientations simultaneously for content that overflows in both directions.

### Overflow Detection

The ScrollArea automatically detects content overflow and manages scrollbar visibility accordingly. This includes:

- Automatic detection of viewport size changes
- Handling of browser zoom levels
- Response to content size changes

The overflow state is exposed through the `data-has-overflow` attribute on the root element.

## Technical Constraints

1. Viewport Dimensions
   - The ScrollArea requires explicit dimensions (height/width) on the root element
   - Dimensions can be set via inline styles or CSS classes

2. Performance Considerations
   - Scrollbar visibility changes use CSS transitions for smooth animations
   - Thumb position updates are optimized using transform translations
   - Overflow detection is debounced during zoom operations

3. Browser Support Requirements
   - Requires browsers that support:
     - ResizeObserver API
     - CSS transforms
     - Mouse event handling
     - Wheel event normalization

These technical aspects ensure smooth scrolling behavior while maintaining performance across different browsers and scenarios.Based on the provided examples and API documentation, I don't see any form-specific examples or functionality in the ScrollArea component. The ScrollArea component is primarily focused on providing scrollable content areas with customizable scrollbars and does not include form-specific features such as:

- Form integration
- Form validation
- Form submission
- Form state handling

The examples provided (`both`, `horizontal`, `vertical`) demonstrate the basic usage and layout functionality of the ScrollArea component, but none are related to form functionality.

Therefore, there is no form-specific documentation to write for this component.Looking through the provided examples and implementation, I don't see any environment-specific examples (like CSR vs SSR) or features that would require special documentation about environmental concerns.

The examples provided (`both`, `horizontal`, `vertical`) demonstrate basic usage patterns and different scrollbar orientations, but don't showcase any environment-specific behavior.

The ScrollArea component appears to work consistently across server and client environments without any special considerations or limitations. It handles both initial server-side rendering and client-side hydration seamlessly through Qwik's default behavior.

Since there are no environment-specific examples or features to document, this section should be empty to avoid creating unnecessary documentation.

---

# Calendar
Select dates with an interactive grid that supports keyboard navigation and localization.
<Showcase name="hero" />
## Features
<Features api={api} />
## Anatomy 
<AnatomyTable api={api} />
## Examples
### Basic Usage
The calendar can be implemented with minimal configuration using the compound components pattern. The example below shows a basic calendar setup with navigation controls and date selection.
<Showcase name="hero" />
This example demonstrates:
- `Calendar.Root` as the main container with `locale` and `showWeekNumber` props
- `Calendar.Header` containing navigation controls and month/year display
- `Calendar.Grid` rendering the date grid with `Calendar.GridDay` for individual dates
- Date selection handling through `onDateChange$` prop on `Calendar.GridDay`
Key API highlights:
- `locale` prop for internationalization (defaults to "en")
- `showWeekNumber` prop to display week numbers (defaults to false) 
- `showDaysOfWeek` prop to show/hide weekday headers (defaults to true)
- `onDateChange$` event handler for date selection
- `data-selected` and `data-current` attributes for styling selected and current dates
The calendar supports full keyboard navigation and follows WAI-ARIA calendar design patterns for accessibility.
Note: Since only the "hero" example is available in the provided examples list, I've limited the documentation to this basic usage section. Additional sections for Visual Features and Advanced Usage would require more example implementations.## Component State
### Internal State Structure
The Calendar component maintains several key pieces of state through the `CalendarContext`:
```typescript
type CalendarContext = {
  locale: Locale;
  defaultDate: LocalDate;
  activeDate: Signal<LocalDate | null>;
  dateToFocus: Signal<LocalDate>;
  showWeekNumber: boolean;
  showDaysOfWeek: boolean;
  daysOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
  datesArray: Signal<(string | null)[][]>;
  monthToRender: Signal<Month>;
  yearToRender: Signal<number>;
  currentDate: LocalDate;
  localId: string;
  isPopoverOpenSig: Signal<boolean>;
};
```
Core state values include:
- `activeDate`: Tracks the currently selected date
- `dateToFocus`: Manages keyboard focus within the calendar grid
- `monthToRender` and `yearToRender`: Control which month/year is displayed
- `datesArray`: Contains the matrix of dates to render in the grid
The state is initialized in `CalendarRoot` with default values and optional props:
```typescript
const defaultDate = props.defaultDate ?? currentDate;
const activeDate = useSignal<LocalDate | null>(null);
const monthToRender = useSignal<Month>(defaultDate.split("-")[1] as Month);
const yearToRender = useSignal<number>(+defaultDate.split("-")[0]);
```
### State Updates
The calendar state updates through several patterns:
1. Date Selection:
```typescript
onClick$={[
  $(() => {
    context.activeDate.value = day as LocalDate;
    onDateChange$?.(day as LocalDate);
  })
]}
```
2. Month Navigation:
```typescript
// Previous month
const decreaseDate = $(() => {
  if (monthToRender.value === "01") {
    monthToRender.value = "12";
    yearToRender.value--;
    return;
  }
  monthToRender.value = String(+monthToRender.value - 1).padStart(2, "0") as Month;
});
// Next month
const increaseDate = $(() => {
  if (monthToRender.value === "12") {
    monthToRender.value = "01";
    yearToRender.value++;
    return;
  }
  monthToRender.value = String(+monthToRender.value + 1).padStart(2, "0") as Month;
});
```
3. Focus Management:
The calendar maintains focus state through the `dateToFocus` signal, which updates based on keyboard navigation:
```typescript
const updateFocus = (newIdx: number, newDate: LocalDate | null = null) => {
  const dateToSet = newDate ?? (buttons[newIdx].getAttribute("data-value") as LocalDate);
  context.dateToFocus.value = dateToSet;
  elFocus?.setAttribute("tabindex", "-1");
  buttons[newIdx].setAttribute("tabindex", "0");
  buttons[newIdx].focus({ preventScroll: true });
};
```
The state updates are reactive and trigger re-renders of the calendar grid while maintaining proper focus management and selection state.Based on the provided implementation and examples, I'll document the calendar configuration options:
## Core Configuration
### Locale and Date Format
The calendar supports localization through the `locale` prop on `Calendar.Root`. Currently, it supports:
- Default locale: `"en"`
- Date format: `YYYY-MM-DD`
As shown in the hero example above, the calendar uses the default English locale for month names, weekday labels, and date formatting.
### Initial Display
The calendar's initial display can be configured through these `Calendar.Root` props:
```typescript
{
  // Initial date shown when calendar loads
  defaultDate?: LocalDate;  
  // Whether to show week numbers
  showWeekNumber?: boolean; // default: false
  // Whether to show days of week header
  showDaysOfWeek?: boolean; // default: true
  // Show complete weeks with days from adjacent months
  fullWeeks?: boolean; // default: false
}
```
### Grid Structure
The calendar grid layout is controlled through `Calendar.Grid` and supports:
- Week numbers display (optional)
- Days of week header (optional) 
- Full/partial week display
- Responsive grid sizing
> The grid automatically adjusts its layout based on the `showWeekNumber` and `showDaysOfWeek` props.
## Advanced Configuration
### Date Selection
The calendar supports controlled and uncontrolled date selection through:
```typescript
{
  // Currently selected date (controlled)
  date?: LocalDate;
  // Handler for date selection
  onDateChange$?: (date: LocalDate) => void;
}
```
### Date Constraints
The calendar enforces these date format constraints:
- Dates must be in `YYYY-MM-DD` format
- Month values must be `01-12`
- Day values must be valid for the given month
- Invalid date formats will throw an error
> The calendar validates date strings against the regex pattern: `/^\d{4}-(0[1-9]|1[0-2])-\d{2}$/`
### Popover Integration
When used with popover functionality, the calendar supports:
```typescript
{
  // Control popover open state
  "bind:open"?: Signal<boolean>;
}
```
This enables integration with popover positioning and focus management systems.Based on the provided code and examples, there are no form-specific features or examples shown for the Calendar component. The component appears to be focused on date selection and display functionality rather than form integration.
The example provided (`hero`) demonstrates basic date selection and display, but does not show any form-specific implementations such as:
- Form field integration
- Form validation
- Form submission handling
- Form state management
Since there are no form-specific features to document, this section can be skipped. The Calendar component's primary purpose appears to be as a standalone date selection interface rather than a form input component.
If form integration is needed, it would need to be implemented by capturing the selected date value (as shown in the hero example using `onDateChange$`) and manually integrating it into a form system.Based on the provided examples and implementation, I don't see any environment-specific examples (like CSR vs SSR) for the Calendar component. The only example provided shows basic usage of the calendar component.
Since there are no environment-specific examples or features to document, I'll skip this section as per the rules. The Calendar component appears to work consistently across environments without any special considerations needed for server vs client rendering or platform-specific behavior.
If environment-specific examples or features are added in the future, this section should be updated to document those specific cases.

---

# Checklist
A group of selectable items that can be toggled individually or all at once.
<Showcase name="hero" />
## Features
<Features api={api} />
## Anatomy
<AnatomyTable api={api} />
## Examples
### Basic Usage
Create a simple checklist with multiple selectable items.
<Showcase name="select-all" />
This example demonstrates the core functionality of the checklist component:
- `Checklist.Root` serves as the container for all checklist items
- `Checklist.SelectAll` creates a master checkbox that controls all items
- `Checklist.Item` represents individual checkable items
- `Checklist.ItemTrigger` provides the interactive area for each item
- `Checklist.ItemIndicator` displays the checked state
- `Checklist.Label` and `Checklist.ItemLabel` provide accessible text labels
The select-all functionality automatically manages the state of all items, including a mixed state when only some items are selected.
Note: The available examples are limited to "hero" and "select-all". Additional examples would typically cover visual features and advanced usage patterns, but they are not included in the provided example list.## Component State
### Internal State Structure
The Checklist component maintains two primary state values through the `ChecklistContext`:
```typescript
type ChecklistContext = {
  isAllCheckedSig: Signal<boolean | "mixed">;
  checkedStatesSig: Signal<(boolean | "mixed")[]>;
};
```
1. `isAllCheckedSig`: Tracks the state of the select-all checkbox
   - `true`: All items are checked
   - `false`: No items are checked 
   - `"mixed"`: Some items are checked
2. `checkedStatesSig`: Maintains an array of individual checkbox states
The state is initialized when the `ChecklistRoot` component mounts:
```typescript
const isAllCheckedSig = useSignal(false);
const checkedStatesSig = useSignal<(boolean | "mixed")[]>([]);
```
### State Updates
The Checklist implements a bidirectional state management system:
1. Select All → Individual Items
```typescript
useTask$(function checkAllManager({ track }) {
  track(() => context.isAllCheckedSig.value);
  if (context.isAllCheckedSig.value === true) {
    isCheckedSig.value = true;
  } else if (context.isAllCheckedSig.value === false) {
    isCheckedSig.value = false;
  }
});
```
2. Individual Items → Select All
```typescript
useTask$(function checkItemsManager({ track }) {
  track(() => isCheckedSig.value);
  context.checkedStatesSig.value[index] = isCheckedSig.value;
  if (context.checkedStatesSig.value.every((state) => state === true)) {
    context.isAllCheckedSig.value = true;
  } else if (context.checkedStatesSig.value.every((state) => state === false)) {
    context.isAllCheckedSig.value = false;
  } else {
    context.isAllCheckedSig.value = "mixed";
  }
});
```
As shown in the "select-all" example above, when the select-all checkbox is toggled:
- It updates `isAllCheckedSig`
- The change propagates to all individual items
- Each item updates its local state
- The collective state is reflected back to determine if all/some/none are checked
This creates a synchronized state system where:
- Individual items can be toggled independently
- The select-all checkbox reflects the aggregate state
- Toggling select-all affects all items simultaneouslyBased on the provided implementation and examples, I'll document the configuration options for the Checklist component.
## Core Configuration
### Basic Structure
The Checklist component requires a specific structure to function properly. The root component must contain individual checklist items, each with their own trigger and indicator components.
As shown in the `hero` example above, the basic structure consists of:
- `Checklist.Root` - The container component
- `Checklist.Item` - Individual checkbox items
- `Checklist.ItemTrigger` - The interactive trigger element
- `Checklist.ItemIndicator` - Visual indicator for checked state
### Select All Configuration
The Checklist supports a "select all" functionality that can be implemented using dedicated components. As shown in the `select-all` example above, this requires:
- `Checklist.SelectAll` - The select all trigger
- `Checklist.SelectAllIndicator` - Visual indicator for the select all state
- `Checklist.Label` - Label for the select all checkbox
The select all functionality automatically manages three states:
- Unchecked (when no items are selected)
- Mixed (when some items are selected)
- Checked (when all items are selected)
### State Management
The Checklist uses an internal context system to manage the state of all checkboxes. Key technical details:
```typescript
type ChecklistContext = {
  isAllCheckedSig: Signal<boolean | "mixed">;
  checkedStatesSig: Signal<(boolean | "mixed")[]>;
};
```
> The context automatically synchronizes states between individual items and the select all checkbox. No additional configuration is required.
### Item Tracking
The Checklist internally tracks items using index positions. This is handled automatically, but you should be aware that:
```typescript
type PublicChecklistItemProps = {
  _index?: number; // Automatically managed
};
type PublicChecklistRootProps = {
  _numItems?: number; // Automatically managed
};
```
> These internal props are managed by the component and should not be set manually.
The component will throw an error if a Checklist Item is rendered without proper index tracking:
```typescript
if (props._index === undefined) {
  throw new Error("Qwik Design System: Checklist Item must have an index");
}
```Based on the provided implementation and examples, I'll document the form-specific features of the Checklist component.
## Forms
The Checklist component provides form integration through the `<Checklist.HiddenInput>` component, which manages multiple checkbox form inputs. This allows the checklist to work within forms while maintaining its group functionality.
<Showcase name="select-all" />
In this example, the checklist demonstrates form integration with multiple selectable items. The `<Checklist.HiddenInput>` component manages the form state for all checkbox items within the checklist group.
## Form State Management
The checklist maintains synchronized state management between individual items and the select-all functionality. When used in forms:
- Individual items can be selected/deselected independently
- The select-all state automatically updates based on item selections:
  - All items checked: select-all is checked
  - No items checked: select-all is unchecked
  - Some items checked: select-all shows a mixed state
## Form Validation
Form validation can be handled through the `<Checklist.ErrorMessage>` component. When rendered, it indicates an invalid state for the checklist group.
The error message component integrates with the checklist's accessibility features and can be used with any form validation library.
Note: The examples provided don't explicitly show form validation, but the component includes the necessary structure through `<Checklist.ErrorMessage>` to support validation scenarios.Based on the provided examples and implementation, I don't see any environment-specific examples (like CSR vs SSR) or environment-specific features that need to be documented separately.
The examples provided ("hero" and "select-all") demonstrate basic usage patterns and state management, but don't showcase any environment-specific behaviors or rendering cases.
Following the strict rules provided, I should not create documentation for basic usage patterns or features that have been covered in other sections. Since there are no environment-specific examples or features to document, this section should remain empty.

---

# Checklist
A group of selectable items that can be toggled together or individually.
<Showcase name="hero" />
## Features
<Features api={api} />
## Anatomy
<AnatomyTable api={api} />
## Examples
### Basic Usage
The basic checklist setup allows users to select multiple items independently.
<Showcase name="hero" />
This example demonstrates:
- Using `Checklist.Root` as the container
- Individual items created with `Checklist.Item`
- Each item has a trigger, indicator, and label
- Custom icon using `LuCheck` for the checked state
### Advanced Usage
The select-all pattern enables bulk selection of all checklist items.
<Showcase name="select-all" />
This example shows:
- `Checklist.SelectAll` trigger for controlling all items
- `Checklist.SelectAllIndicator` displaying mixed states with different icons
- Nested items indented under the select-all control
- Synchronized state between select-all and individual items
- Mixed state indication when only some items are selected
The select-all example demonstrates how the checklist manages group selection while maintaining individual item control. The mixed state is shown using a minus icon when some but not all items are selected.
Note: Both examples use the same base styling for consistency, but the select-all pattern adds hierarchical structure through layout and indentation.## Component State
### Internal State Structure
The Checklist component manages state through a context-based system that coordinates between the select-all functionality and individual checklist items.
Core state values:
```typescript
type ChecklistContext = {
  isAllCheckedSig: Signal<boolean | "mixed">;
  checkedStatesSig: Signal<(boolean | "mixed")[]>;
};
```
- `isAllCheckedSig`: Controls the state of the select-all checkbox
- `checkedStatesSig`: Tracks the checked state of each individual item
The state is initialized in the `ChecklistRoot` component:
```typescript
const isAllCheckedSig = useSignal(false);
const checkedStatesSig = useSignal<(boolean | "mixed")[]>([]);
```
### State Updates
The state updates follow a bidirectional pattern:
1. Select All → Individual Items:
```typescript
useTask$(function checkAllManager({ track }) {
  track(() => context.isAllCheckedSig.value);
  if (context.isAllCheckedSig.value === true) {
    isCheckedSig.value = true;
  } else if (context.isAllCheckedSig.value === false) {
    isCheckedSig.value = false;
  }
});
```
2. Individual Items → Select All:
```typescript
useTask$(function checkItemsManager({ track }) {
  track(() => isCheckedSig.value);
  context.checkedStatesSig.value[index] = isCheckedSig.value;
  // Update select all state based on item states
  if (context.checkedStatesSig.value.every((state) => state === true)) {
    context.isAllCheckedSig.value = true;
  } else if (context.checkedStatesSig.value.every((state) => state === false)) {
    context.isAllCheckedSig.value = false;
  } else {
    context.isAllCheckedSig.value = "mixed";
  }
});
```
As shown in the `select-all` example above, when individual items are checked/unchecked:
- The select-all checkbox shows:
  - Checked (✓) when all items are selected
  - Mixed state (-) when some items are selected
  - Unchecked when no items are selected
- Toggling the select-all checkbox affects all individual item states
The state management ensures consistent synchronization between the select-all functionality and individual checklist items through Qwik's reactive system.Based on the provided implementation and examples, I'll document the configuration options for the Checklist component.
## Core Configuration
### Basic Structure
The Checklist component requires a specific structure to function properly. As shown in the `hero` example above, the basic configuration includes:
- `<Checklist.Root />` as the main container
- `<Checklist.Item />` for individual checkboxes
- `<Checklist.ItemTrigger />` for the interactive element
- `<Checklist.ItemIndicator />` for the visual state
- `<Checklist.ItemLabel />` for the text label
### Select All Configuration
The Checklist supports a "select all" feature that can be configured using dedicated components. As demonstrated in the `select-all` example above, this requires:
- `<Checklist.SelectAll />` for the main trigger
- `<Checklist.SelectAllIndicator />` for the visual state
- `<Checklist.Label />` for the select all label
The select all functionality automatically manages the state of all child checkboxes:
- When all items are checked, the select all checkbox is checked
- When some items are checked, the select all checkbox shows a mixed state
- When no items are checked, the select all checkbox is unchecked
### State Management
The Checklist uses an internal context system to manage state synchronization between the select all checkbox and individual items. This is handled automatically and requires no additional configuration.
> Note: The Checklist maintains an array of checked states internally, so you don't need to manage individual checkbox states manually.
### Technical Constraints
1. Each `<Checklist.Item />` must be a direct child of `<Checklist.Root />` for proper state management.
2. The select all configuration must be placed before the individual checklist items in the DOM structure.
3. The component uses a group role by default and should not be modified for accessibility compliance.
These configuration options provide the foundation for building accessible and interactive checklists with synchronized state management.Based on the provided implementation and examples, I'll document the form-specific features of the Checklist component.
## Forms
The Checklist component provides form integration through the `<Checklist.HiddenInput>` component, which manages multiple checkbox form inputs.
<Showcase name="hero" />
The Checklist can be used in forms to handle multiple selections as a group. The component maintains synchronized state between the select-all functionality and individual items.
## Validation
The Checklist supports form validation through the `<Checklist.ErrorMessage>` component. When rendered, it indicates an invalid state for the checklist group.
<Showcase name="select-all" />
The error message can be used to display validation feedback when:
- Required selections are not met
- The number of selected items is invalid
- Any other group-level validation rules are violated
This validation system allows integration with any form validation library while maintaining the component's accessibility and state management features.
Note: The examples provided focus on basic usage and select-all functionality. For specific form validation examples, please refer to your preferred form validation library's documentation.Looking through the provided examples and implementation, I don't see any environment-specific examples (like CSR vs SSR) or environment-specific features that need to be documented separately.
The examples provided ("hero" and "select-all") demonstrate basic usage patterns and state management, but don't showcase any environment-specific behaviors or rendering cases.
Since there are no environment-specific examples or features to document, I'll leave this section empty in accordance with the strict rules provided.
If environment-specific examples or features are added in the future (such as SSR behavior, hydration patterns, or platform-specific considerations), they should be documented here.

---

# Scroll Area
A customizable container that adds scrollbars when content overflows its boundaries.
<Showcase name="both" />
## Features
<Features api={api} />
## Anatomy 
<AnatomyTable api={api} />
## Examples
### Basic Usage
The scroll area provides a clean way to handle content overflow with customizable scrollbars. The basic setup includes a root component, viewport, and scrollbars.
<Showcase name="vertical" />
The example demonstrates:
- `ScrollArea.Root` as the container
- `ScrollArea.Viewport` wrapping the content
- `ScrollArea.Scrollbar` with `orientation="vertical"` for vertical scrolling
- `ScrollArea.Thumb` for the draggable scrollbar handle
### Visual Features
#### Horizontal Scrolling
For content that extends beyond the horizontal bounds, add a horizontal scrollbar.
<Showcase name="horizontal" />
This example shows:
- `ScrollArea.Scrollbar` with `orientation="horizontal"` 
- Automatic thumb sizing based on content width
- Smooth horizontal scrolling behavior
#### Both Scrollbars
When content overflows in both directions, you can combine vertical and horizontal scrollbars.
<Showcase name="both" />
This setup demonstrates:
- Multiple `ScrollArea.Scrollbar` components
- Independent vertical and horizontal scrolling
- Automatic corner handling where scrollbars meet
### Advanced Usage
#### Scrollbar Visibility Control
The scroll area supports different visibility modes through the `type` prop on `ScrollArea.Root`.## Component State
### Internal State Structure
The ScrollArea component maintains several key state values through Qwik signals:
```typescript
// Core state signals
const viewportRef = useSignal<HTMLDivElement>();
const verticalScrollbarRef = useSignal<HTMLDivElement>();
const horizontalScrollbarRef = useSignal<HTMLDivElement>(); 
const rootRef = useSignal<HTMLDivElement>();
const thumbRef = useSignal<HTMLDivElement>();
const isScrolling = useSignal(false);
const isHovering = useSignal(false);
const scrollTimeout = useSignal<number>();
const hasOverflow = useSignal(false);
```
These signals form the foundation of the ScrollArea's state management:
- `hasOverflow`: Tracks whether content exceeds viewport dimensions
- `isScrolling`: Indicates active scrolling state
- `isHovering`: Tracks mouse hover state
- `scrollTimeout`: Manages scrollbar hide delay timing
### State Updates
The ScrollArea implements several state update patterns:
1. Overflow Detection:
```typescript
const updateOverflow = $((viewport: HTMLElement) => {
  const hasVerticalOverflow = viewport.scrollHeight > viewport.clientHeight;
  const hasHorizontalOverflow = viewport.scrollWidth > viewport.clientWidth;
  context.hasOverflow.value = hasVerticalOverflow || hasHorizontalOverflow;
});
```
2. Scroll State Management:
```typescript
if (context.type === "scroll") {
  context.isScrolling.value = true;
  clearTimeout(context.scrollTimeout.value);
  context.scrollTimeout.value = setTimeout(() => {
    context.isScrolling.value = false;
  }, context.hideDelay);
}
```
3. Hover State:
```typescript
const onMouseEnter$ = $(() => {
  if (type === "hover") {
    isHovering.value = true;
  }
});
const onMouseLeave$ = $(() => {
  if (type === "hover") {
    isHovering.value = false;
  }
});
```
4. Drag State:
```typescript
const isDragging = useSignal(false);
const dragData = useSignal({
  startClientY: 0,
  startClientX: 0,
  startScrollTop: 0,
  startScrollLeft: 0,
  activeThumb: null,
  activeScrollbar: null
});
```
The state updates are triggered by:
- Scroll events
- Mouse interactions
- Window resize
- Zoom level changes
- Content overflow changes
State visibility is determined by the `type` prop:
- `"hover"`: Shows scrollbars on hover when content overflows
- `"scroll"`: Shows scrollbars during active scrolling
- `"auto"`: Shows scrollbars when content overflows
- `"always"`: Always shows scrollbars when content overflows
<Showcase name="both" />
In this example, both vertical and horizontal scrollbars are shown, demonstrating how the component manages multiple scrollbar states simultaneously.Based on the provided examples and API documentation, I'll write about the ScrollArea configuration options.
## Scrollbar Visibility
### Core Behavior
The ScrollArea component supports four visibility modes controlled by the `type` prop on `ScrollArea.Root`:
- `hover` (default): Shows scrollbars when hovering over the scroll area
- `scroll`: Shows scrollbars during scrolling
- `auto`: Shows scrollbars when content overflows
- `always`: Shows scrollbars whenever content overflows
As shown in the `hover-test` example above, scrollbars appear on hover and hide when the mouse leaves the scroll area.
### Hide Delay
When using `type="scroll"`, you can customize how long scrollbars remain visible after scrolling stops using the `hideDelay` prop:
```typescript
type ScrollAreaRootProps = {
  hideDelay?: number; // milliseconds
}
```
The default delay is 600ms. As shown in the `custom-delay-test` example above, you can extend this delay to 1000ms for better visibility.
## Scrollbar Orientation
### Basic Configuration
ScrollArea supports both vertical and horizontal scrollbars through the `orientation` prop on `ScrollArea.Scrollbar`:
```typescript
type ScrollBarProps = {
  orientation: "vertical" | "horizontal";
}
```
As shown in the `both` example above, you can include both orientations simultaneously for content that overflows in both directions.
### Overflow Detection
The component automatically detects content overflow and updates scrollbar visibility accordingly. This behavior is demonstrated in all examples but is particularly visible in the `auto-test` example where scrollbars only appear when content exceeds the viewport dimensions.
Key technical considerations:
- Overflow detection is responsive to window resize events
- Browser zoom level changes trigger overflow recalculation
- The component maintains proper thumb positioning during scroll events
- Scrollbar visibility updates are debounced for performance
> Note: The overflow detection system works with dynamic content and responds to DOM mutations that affect content size.Looking through the provided examples and implementation, I don't see any specific form-related examples or functionality for the ScrollArea component. The ScrollArea component is primarily focused on providing scrollable content areas with customizable scrollbars, rather than form integration.
The component doesn't include:
- Form field integration
- Form validation features
- Form submission handling
- Form state management
Therefore, there is no form-specific configuration section needed for this component.
If you need form functionality, you would need to place form elements inside the ScrollArea's viewport, but the ScrollArea itself doesn't provide any direct form integration features.Looking through the examples provided, I don't see any environment-specific examples (like CSR vs SSR, platform-specific behavior, or environmental dependencies) that would warrant documentation in this section.
The provided examples (`both`, `horizontal`, `vertical`) demonstrate basic usage patterns and different scrollbar orientations, but they don't specifically address environment-related concerns.
Since there are no environment-specific examples or features to document, I'll leave this section empty to avoid creating unnecessary documentation that might confuse users.
If environment-specific examples are added in the future (such as SSR behavior, hydration patterns, or platform-specific implementations), they should be documented here.

---

